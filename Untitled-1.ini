 Je suis maintenant dans le dossier /Users/mac/Documents/Projet_sprit.

> analyse de fond en comble pour comprendre comment est implementer TTS 
  Coqui/XTTS-v2 dans le projet

âº Update Todos
  â¿ Â â˜ Analyser la structure du projet pour identifier les composants TTS
     â˜ Rechercher les fichiers liÃ©s Ã  Coqui/XTTS-v2
     â˜ Analyser l'implÃ©mentation du TTS dans le code
     â˜ Examiner les dÃ©pendances et configuration TTS
     â˜ Documenter l'architecture TTS complÃ¨te

âº List(.)
  â¿ Â Listed 889 paths (ctrl+r to expand)

âº Search(pattern: "coqui|XTTS")
  â¿ Â Found 38 files (ctrl+r to expand)

âº Update Todos
  â¿ Â â˜’ Analyser la structure du projet pour identifier les composants TTS
     â˜’ Rechercher les fichiers liÃ©s Ã  Coqui/XTTS-v2
     â˜ Analyser l'implÃ©mentation du TTS dans le code
     â˜ Examiner les dÃ©pendances et configuration TTS
     â˜ Documenter l'architecture TTS complÃ¨te

âº Read(lib/core/services/coqui_tts_service.dart)
  â¿ Â Read 512 lines (ctrl+r to expand)
  â¿ Â CLAUDE.md

âº Read(lib/core/services/smart_tts_service.dart)
  â¿ Â Read 571 lines (ctrl+r to expand)

âº Read(lib/core/services/tts_config_service.dart)
  â¿ Â Read 146 lines (ctrl+r to expand)

âº Read(docs/COQUI_TTS_FINAL.md)
  â¿ Â Read 143 lines (ctrl+r to expand)

âº Read(pubspec.yaml)
  â¿ Â Read 92 lines (ctrl+r to expand)

âº Update Todos
  â¿ Â â˜’ Analyser la structure du projet pour identifier les composants TTS
     â˜’ Rechercher les fichiers liÃ©s Ã  Coqui/XTTS-v2
     â˜’ Analyser l'implÃ©mentation du TTS dans le code
     â˜’ Examiner les dÃ©pendances et configuration TTS
     â˜ Documenter l'architecture TTS complÃ¨te

âº ğŸ“Š Analyse ComplÃ¨te : ImplÃ©mentation TTS Coqui/XTTS-v2

  ğŸ—ï¸ Architecture GÃ©nÃ©rale

  Structure TTS Multi-Provider

  SmartTtsService (Orchestrateur principal)
  â”œâ”€â”€ CoquiTtsService (XTTS-v2 sur VPS)
  â”‚   â”œâ”€â”€ API REST: 168.231.112.71:8001
  â”‚   â”œâ”€â”€ Cache sÃ©curisÃ© AES-256
  â”‚   â””â”€â”€ Retry avec exponential backoff
  â””â”€â”€ FlutterTtsAudioService (Fallback systÃ¨me)
      â””â”€â”€ Voix natives iOS/Android

  ğŸ”§ Services Principaux

  1. CoquiTtsService (lib/core/services/coqui_tts_service.dart)

  - Endpoint: http://168.231.112.71:8001/api/tts
  - Authentification: API Key stockÃ©e via FlutterSecureStorage
  - Format audio: MP3 encodÃ© en Base64
  - Langues: FranÃ§ais, Arabe, Anglais, Espagnol
  - Timeouts dynamiques: 45s â†’ 10min selon longueur texte

  Points ClÃ©s Techniques :

  // Timeout adaptatif pour textes longs
  final estimatedSeconds = (text.length / 20).ceil() + 40;
  final dynamicTimeout = Duration(seconds: estimatedSeconds.clamp(45,
  600));

  // Circuit breaker aprÃ¨s 5 Ã©checs consÃ©cutifs
  if (_consecutiveFailures >= _maxConsecutiveFailures) {
    throw Exception('Service TTS temporairement indisponible');
  }

  2. SmartTtsService (lib/core/services/smart_tts_service.dart)

  - Orchestrateur intelligent avec choix utilisateur
  - Queue de synthÃ¨se diffÃ©rÃ©e pour optimisation cache
  - DÃ©coupage automatique des textes >2000 caractÃ¨res
  - MÃ©triques de performance intÃ©grÃ©es

  Logique de DÃ©cision :

  // Respecte le choix utilisateur (pas de fallback automatique)
  final bool useCoqui = _config.preferredProvider == 'coqui' &&
      _coquiService != null &&
      hasValidApiKey;

  3. TtsConfigService (lib/core/services/tts_config_service.dart)

  - Configuration sÃ©curisÃ©e via FlutterSecureStorage
  - Endpoint par dÃ©faut: http://168.231.112.71:8001
  - Cache TTL: 7 jours configurable
  - Provider prÃ©fÃ©rÃ©: Choix utilisateur stockÃ©

  ğŸ” SÃ©curitÃ© & Cache

  Cache SÃ©curisÃ© (SecureTtsCacheService)

  - Chiffrement AES-256 des fichiers audio
  - ClÃ© de cache : hash(provider + text + voice + speed + pitch)
  - TTL configurÃ© : 7 jours par dÃ©faut
  - Limite stockage : 100MB

  Stockage SÃ©curisÃ©

  // API Key protÃ©gÃ©e
  static const _keyCoquiApiKey = 'tts_coqui_api_key';
  await _storage.write(key: _keyCoquiApiKey, value: apiKey);

  // Masquage pour logs
  String get maskedApiKey => '${coquiApiKey.substring(0, 8)}...';

  ğŸ›ï¸ Interface Utilisateur

  Configuration dans ParamÃ¨tres

  - Chemin : ParamÃ¨tres > Voix et Lecture > Choix du moteur
  - Options :
    - Coqui TTS : QualitÃ© naturelle (par dÃ©faut)
    - Voix systÃ¨me : Rapide mais robotique

  UX OptimisÃ©e

  - Indicateur de chargement premiÃ¨re synthÃ¨se
  - Messages informatifs : "PremiÃ¨re synthÃ¨se... Les suivantes seront
  instantanÃ©es !"
  - Pas de fallback automatique : Respect du choix utilisateur

  ğŸ“¡ IntÃ©gration API

  Payload RequÃªte

  {
    "text": "Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ­ÙˆÙŠÙ„Ù‡ Ø¥Ù„Ù‰ ØµÙˆØª",
    "language": "ar",
    "voice_type": "female",
    "rate": "+0%"
  }

  RÃ©ponse

  {
    "audio": "UklGRlaDAABXQVZFZm10IBAAAAABAAEA..." // Base64
  }

  âš¡ Performance & MÃ©triques

  Performances ObservÃ©es

  | MÃ©trique          | Valeur        |
  |-------------------|---------------|
  | SynthÃ¨se initiale | ~1-3 secondes |
  | Audio FR (moyen)  | ~26 KB        |
  | Audio AR (moyen)  | ~31 KB        |
  | Cache hit         | InstantanÃ©    |
  | Timeout max       | 10 minutes    |

  Optimisations

  - DÃ©coupage intelligent des textes longs
  - Queue background pour prÃ©-cache
  - Retry exponential backoff : 100ms â†’ 800ms
  - Circuit breaker aprÃ¨s 5 Ã©checs

  ğŸ”„ Fallback & Robustesse

  StratÃ©gie Sans Fallback Automatique

  // PAS de fallback automatique - respecte le choix utilisateur
  throw Exception(
    'Coqui TTS non disponible. Veuillez rÃ©essayer ou changer de provider.'
  );

  Gestion d'Erreurs Robuste

  - Retry automatique sur erreurs rÃ©seau
  - Circuit breaker temporaire
  - Logs structurÃ©s pour debugging
  - MÃ©triques de success rate

  ğŸ“Š IntÃ©gration Riverpod

  Providers Architecture

  final smartTtsServiceProvider = Provider<AudioTtsService>((ref) {
    // Configuration async
    return configAsync.when(
      data: (config) => SmartTtsService(...),
      loading: () => ref.watch(flutterTtsServiceProvider),
      error: (error, stack) => ref.watch(flutterTtsServiceProvider),
    );
  });

  ğŸ¯ Points Forts Architecture

  âœ… Avantages Techniques

  1. Architecture modulaire : Services dÃ©couplÃ©s et testables
  2. SÃ©curitÃ© first : API keys et cache chiffrÃ©s
  3. Performance intelligente : Cache, timeouts adaptatifs, queue
  4. UX transparente : ContrÃ´le utilisateur total
  5. Robustesse : Circuit breaker, retry, logs complets

  ğŸ” Innovation Technique

  - Timeout dynamique basÃ© sur longueur de texte
  - DÃ©coupage intelligent prÃ©servant le sens
  - Queue de synthÃ¨se diffÃ©rÃ©e pour optimisation
  - Choix utilisateur respectÃ© sans confusion

âº Update Todos
  â¿ Â â˜’ Analyser la structure du projet pour identifier les composants TTS
     â˜’ Rechercher les fichiers liÃ©s Ã  Coqui/XTTS-v2
     â˜’ Analyser l'implÃ©mentation du TTS dans le code
     â˜’ Examiner les dÃ©pendances et configuration TTS
     â˜’ Documenter l'architecture TTS complÃ¨te

âº L'implÃ©mentation TTS Coqui/XTTS-v2 est trÃ¨s sophistiquÃ©e avec une
  architecture multi-provider intelligente, un cache sÃ©curisÃ©, et une UX
  optimisÃ©e donnant le contrÃ´le total Ã  l'utilisateur entre qualitÃ© (Coqui)
   et rapiditÃ© (systÃ¨me natif).

> voici ma question,comment je puisse entrainer TTS coqui que j'ai installe
   dans mon serveur VPS pour avoir diffÃ©rente voie, je voulais l'entrainer 
  pour la lecture de texte coranique avec des voies de lecture qui existe 
  comme miserai Rashid, Abdul Rahman As Sudais, Ali al Hudhaify, Afif 
  Mohammed Taj etc â€¦ ,j'aimerai que tu me reponde par oui ou non et si 
  c'est oui de me faire une implementation et pouvoir modifier les fichiers
   de serveur vps alors propose moi un plan, lis le fichier joint-ci pour 
  prendre quelque connaissance aussi 
  /Users/mac/Documents/Projet_sprit/conversation_tts_quranic.md

âº Read(conversation_tts_quranic.md)
  â¿ Â Read 858 lines (ctrl+r to expand)

âº ğŸ“‹ RÃ©ponse : EntraÃ®nement TTS Coqui pour Voix de RÃ©citateurs Coraniques

  OUI

  C'est tout Ã  fait possible d'entraÃ®ner votre serveur Coqui/XTTS-v2 avec
  des voix de rÃ©citateurs coraniques comme Mishary Rashid, Abdul Rahman
  As-Sudais, Ali al-Hudhaify, et Afif Mohammed Taj.

  ğŸ¯ Plan d'ImplÃ©mentation

  Phase 1: PrÃ©paration des Ã‰chantillons Vocaux (2-3 jours)

  1.1 Collecte d'Ã‰chantillons Audio

  # Structure sur votre VPS
  mkdir -p
  /var/coqui/quranic_voices/{mishary_rashid,sudais,hudhaify,afif_taj}
  mkdir -p /var/coqui/quranic_voices/source_audio
  mkdir -p /var/coqui/quranic_voices/processed

  1.2 Script de PrÃ©paration Audio

  # prepare_quranic_voices.py
  import torchaudio
  import torch
  from pydub import AudioSegment
  import os

  class QuranicVoicePreparer:
      def __init__(self):
          self.target_sr = 22050
          self.reciters = {
              "mishary_rashid": "Mishary Rashid Alafasy",
              "sudais": "Abdul Rahman As-Sudais",
              "hudhaify": "Ali Al-Hudhaify",
              "afif_taj": "Afif Mohammed Taj"
          }

      def extract_clean_sample(self, source_audio, reciter_name, 
  start_sec=10, duration=15):
          """Extraire 15 secondes de rÃ©citation claire"""
          audio = AudioSegment.from_file(source_audio)

          # Mono + 22050Hz
          audio = audio.set_channels(1).set_frame_rate(self.target_sr)

          # Segment entre 10-25 secondes (Ã©viter dÃ©but/fin)
          start_ms = start_sec * 1000
          segment = audio[start_ms:start_ms + (duration * 1000)]

          # Normaliser et rÃ©duire bruit
          segment = segment.normalize()

          # Sauvegarder
          output_path =
  f"/var/coqui/quranic_voices/{reciter_name}/sample.wav"
          segment.export(output_path, format="wav")

          return output_path

  # Utilisation
  preparer = QuranicVoicePreparer()

  Phase 2: Configuration XTTS-v2 (1 jour)

  2.1 Mise Ã  Jour du Service Coqui

  # quranic_xtts_service.py
  from TTS.api import TTS
  import torch
  import json
  import os

  class QuranicXTTSService:
      def __init__(self):
          self.device = "cuda" if torch.cuda.is_available() else "cpu"
          self.tts =
  TTS("tts_models/multilingual/multi-dataset/xtts_v2").to(self.device)

          # Configuration des rÃ©citateurs
          self.reciters = {
              "mishary_rashid": {
                  "name": "Mishary Rashid Alafasy",
                  "sample":
  "/var/coqui/quranic_voices/mishary_rashid/sample.wav",
                  "speed": 0.85,
                  "temperature": 0.5
              },
              "sudais": {
                  "name": "Abdul Rahman As-Sudais",
                  "sample": "/var/coqui/quranic_voices/sudais/sample.wav",
                  "speed": 0.8,
                  "temperature": 0.45
              },
              "hudhaify": {
                  "name": "Ali Al-Hudhaify",
                  "sample":
  "/var/coqui/quranic_voices/hudhaify/sample.wav",
                  "speed": 0.9,
                  "temperature": 0.5
              },
              "afif_taj": {
                  "name": "Afif Mohammed Taj",
                  "sample":
  "/var/coqui/quranic_voices/afif_taj/sample.wav",
                  "speed": 0.88,
                  "temperature": 0.55
              }
          }

      def synthesize_quranic(self, text, reciter="mishary_rashid"):
          """SynthÃ©tiser avec voix de rÃ©citateur"""
          if reciter not in self.reciters:
              raise ValueError(f"RÃ©citateur {reciter} non disponible")

          config = self.reciters[reciter]

          return self.tts.tts(
              text=text,
              speaker_wav=config["sample"],
              language="ar",
              speed=config["speed"],
              temperature=config["temperature"],
              top_p=0.85,
              top_k=50
          )

  Phase 3: Modification de l'API Existante (1 jour)

  3.1 Extension de l'API VPS

  # Ajouter Ã  votre API existante sur 168.231.112.71:8001
  from quranic_xtts_service import QuranicXTTSService

  app = FastAPI()
  quranic_tts = QuranicXTTSService()

  @app.post("/api/tts/quranic")
  async def synthesize_quranic(request: dict):
      """Nouveau endpoint pour rÃ©citation coranique"""

      text = request.get("text", "")
      reciter = request.get("reciter", "mishary_rashid")
      voice_type = request.get("voice_type", "male")  # IgnorÃ© pour 
  rÃ©citateurs

      try:
          # Utiliser le service de rÃ©citation coranique
          audio_data = quranic_tts.synthesize_quranic(text, reciter)

          # Encoder en base64 comme votre API actuelle
          import base64
          audio_b64 = base64.b64encode(audio_data).decode()

          return {"audio": audio_b64, "reciter": reciter}

      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))

  @app.get("/api/reciters")
  async def list_reciters():
      """Lister les rÃ©citateurs disponibles"""
      return {
          "reciters": list(quranic_tts.reciters.keys()),
          "details": quranic_tts.reciters
      }

  Phase 4: IntÃ©gration Flutter (1 jour)

  4.1 Modification du CoquiTtsService

  // Ajouter Ã  lib/core/services/coqui_tts_service.dart

  class CoquiTtsService {
    // ... code existant ...

    /// Liste des rÃ©citateurs coraniques disponibles
    static const quranicReciters = {
      'mishary_rashid': 'Mishary Rashid Alafasy',
      'sudais': 'Abdul Rahman As-Sudais',
      'hudhaify': 'Ali Al-Hudhaify',
      'afif_taj': 'Afif Mohammed Taj',
    };

    Future<String?> _synthesizeQuranicWithCoqui({
      required String text,
      required String reciter,
      required double speed,
      required String cacheKey,
    }) async {

      // Utiliser l'endpoint dÃ©diÃ© aux rÃ©citateurs
      final response = await _dio.post(
        '${_config.coquiEndpoint}/api/tts/quranic',
        data: {
          'text': text,
          'reciter': reciter,
          'rate': _speedToRate(speed),
        },
        options: Options(headers: {'X-API-Key': _config.coquiApiKey}),
      );

      if (response.statusCode == 200) {
        final audioBase64 = response.data['audio'] as String?;
        if (audioBase64?.isNotEmpty == true) {
          final audioBytes = base64Decode(audioBase64);
          final tempDir = await getTemporaryDirectory();
          final tempFile = File('${tempDir.path}/$cacheKey.mp3');
          await tempFile.writeAsBytes(audioBytes);
          return tempFile.path;
        }
      }
      return null;
    }

    /// Jouer avec voix de rÃ©citateur coranique
    Future<void> playQuranicText(
      String text, {
      required String reciter,
      double speed = 0.85,
    }) async {

      if (!quranicReciters.containsKey(reciter)) {
        throw Exception('RÃ©citateur $reciter non disponible');
      }

      // GÃ©nÃ©rer clÃ© de cache avec rÃ©citateur
      final cacheKey = await _cache.generateKey(
        provider: 'coqui_quranic',
        text: text,
        voice: reciter,
        speed: speed,
        pitch: 1.0,
      );

      // VÃ©rifier cache
      String? audioPath = await _cache.getPath(cacheKey);

      if (audioPath == null || !File(audioPath).existsSync()) {
        audioPath = await _synthesizeQuranicWithCoqui(
          text: text,
          reciter: reciter,
          speed: speed,
          cacheKey: cacheKey,
        );

        if (audioPath != null) {
          await _cache.store(
            key: cacheKey,
            filePath: audioPath,
            metadata: {
              'provider': 'coqui_quranic',
              'reciter': reciter,
              'timestamp': DateTime.now().toIso8601String(),
            },
          );
        }
      }

      if (audioPath != null) {
        await _audioPlayer.setFilePath(audioPath);
        await _audioPlayer.play();
      }
    }
  }

  4.2 Interface Utilisateur - SÃ©lecteur de RÃ©citateur

  // lib/features/settings/quranic_voice_selector.dart
  class QuranicVoiceSelector extends ConsumerWidget {
    @override
    Widget build(BuildContext context, WidgetRef ref) {
      return Column(
        children: [
          Text('Voix de RÃ©citation Coranique'),
          ...CoquiTtsService.quranicReciters.entries.map((entry) {
            return ListTile(
              title: Text(entry.value),
              subtitle: Text('RÃ©citateur: ${entry.key}'),
              onTap: () => _testReciter(entry.key),
            );
          }),
        ],
      );
    }

    Future<void> _testReciter(String reciter) async {
      final tts = ref.read(coquiTtsServiceProvider);
      await tts.playQuranicText(
        'Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø§Ù„Ø±ÙÙ‘Ø­Ù’Ù…ÙÙ°Ù†Ù Ø§Ù„Ø±ÙÙ‘Ø­ÙÙŠÙ…Ù',
        reciter: reciter,
      );
    }
  }

  Phase 5: DÃ©ploiement (1 jour)

  5.1 Script de DÃ©ploiement VPS

  #!/bin/bash
  # deploy_quranic_voices.sh

  # ArrÃªter le service existant
  sudo systemctl stop coqui-tts

  # Backup de la configuration actuelle
  cp -r /var/coqui /var/coqui_backup_$(date +%Y%m%d)

  # CrÃ©er structure pour voix coraniques
  mkdir -p
  /var/coqui/quranic_voices/{mishary_rashid,sudais,hudhaify,afif_taj}

  # Copier les nouveaux fichiers
  cp quranic_xtts_service.py /var/coqui/
  cp prepare_quranic_voices.py /var/coqui/

  # Mettre Ã  jour l'API
  cp api_with_quranic.py /var/coqui/main.py

  # RedÃ©marrer le service
  sudo systemctl start coqui-tts
  sudo systemctl status coqui-tts

  ğŸ“Š Ressources NÃ©cessaires

  Serveur VPS

  - RAM: 4GB minimum (8GB recommandÃ©)
  - CPU: 4 cores minimum
  - Stockage: +2GB pour Ã©chantillons et cache
  - GPU: Optionnel (10x plus rapide)

  Ã‰chantillons Audio

  - DurÃ©e: 10-20 secondes par rÃ©citateur
  - QualitÃ©: Audio clair, sans bruit de fond
  - Format: WAV 22050Hz mono

  âœ… Avantages de cette Approche

  1. IntÃ©gration transparente avec votre systÃ¨me existant
  2. Choix utilisateur entre rÃ©citateurs cÃ©lÃ¨bres
  3. Cache intelligent pour performances optimales
  4. API RESTful maintenant la compatibilitÃ©
  5. DÃ©ploiement incrÃ©mental sans casser l'existant

  ğŸš€ RÃ©sultat Final

  Votre app aura:
  - 4 voix de rÃ©citateurs cÃ©lÃ¨bres pour la lecture coranique
  - SÃ©lection intuitive dans les paramÃ¨tres
  - Performances identiques Ã  votre systÃ¨me actuel
  - Cache optimisÃ© pour lectures rÃ©pÃ©tÃ©es

  Temps estimÃ© total: 5-7 jours pour implÃ©mentation complÃ¨te avec tests.

> genere moi un document memoire markdown  pour cette implementation, tout 
  ce que je dois a preter et les actions que je dois faire sans passer par 
  toi sur le serveur vps et les actions que tu pourras les faires 
  directement via IP du serveur etc fichier audio et texte a preparer, je 
  veux que la lecture soit dans la regle du coran, taswid

âº ğŸ“š MÃ©moire d'ImplÃ©mentation - TTS Coqui pour RÃ©citation Coranique avec 
  Tajweed

  ğŸ“‹ Table des MatiÃ¨res

  1. #vue-densemble
  2. #prÃ©requis-et-prÃ©paration
  3. #actions-utilisateur-sans-assistant
  4. #actions-assistant-via-ip-serveur
  5. #rÃ¨gles-de-tajweed-Ã -respecter
  6. #tests-et-validation
  7. #maintenance-et-surveillance

  ---
  ğŸ¯ Vue d'ensemble

  Objectif

  IntÃ©grer 4 voix de rÃ©citateurs coraniques cÃ©lÃ¨bres dans votre systÃ¨me TTS
   Coqui existant, en respectant les rÃ¨gles de Tajweed pour une rÃ©citation
  authentique.

  RÃ©citateurs Cibles

  - Mishary Rashid Alafasy (Ø§Ù„Ø´ÙŠØ® Ù…Ø´Ø§Ø±ÙŠ Ø±Ø§Ø´Ø¯ Ø§Ù„Ø¹ÙØ§Ø³ÙŠ)
  - Abdul Rahman As-Sudais (Ø§Ù„Ø´ÙŠØ® Ø¹Ø¨Ø¯ Ø§Ù„Ø±Ø­Ù…Ù† Ø§Ù„Ø³Ø¯ÙŠØ³)
  - Ali Al-Hudhaify (Ø§Ù„Ø´ÙŠØ® Ø¹Ù„ÙŠ Ø§Ù„Ø­Ø°ÙŠÙÙŠ)
  - Afif Mohammed Taj (Ø§Ù„Ø´ÙŠØ® Ø¹ÙÙŠÙ Ù…Ø­Ù…Ø¯ ØªØ§Ø¬)

  Architecture Finale

  App Flutter â†’ SmartTtsService â†’ CoquiTtsService â†’ VPS API
  (168.231.112.71:8001)
                                                        â†“
                                                 QuranicXTTSService
                                                        â†“
                                              4 Voix de RÃ©citateurs

  ---
  ğŸ› ï¸ PrÃ©requis et PrÃ©paration

  Serveur VPS - SpÃ©cifications Minimales

  - RAM: 6GB (8GB recommandÃ© pour 4 voix simultanÃ©es)
  - CPU: 4 cores minimum (Intel/AMD x64)
  - Stockage: +5GB libres pour Ã©chantillons et cache
  - OS: Ubuntu 20.04+ ou CentOS 8+
  - Python: 3.8+ avec pip
  - GPU: Optionnel (NVIDIA avec CUDA pour 10x performances)

  Logiciels Ã  Installer sur VPS

  # Outils audio essentiels
  sudo apt update
  sudo apt install ffmpeg sox libsox-fmt-all python3-pip python3-venv

  # VÃ©rifier Python version
  python3 --version  # Doit Ãªtre â‰¥ 3.8

  Droits d'Usage - âš ï¸ IMPORTANT

  - VÃ©rifier les droits d'utilisation des enregistrements des rÃ©citateurs
  - Contacter les dÃ©tenteurs de droits si nÃ©cessaire
  - Usage Ã©ducatif/religieux gÃ©nÃ©ralement autorisÃ© mais Ã  confirmer
  - Respecter les licences Creative Commons si disponibles

  ---
  ğŸ‘¤ Actions Utilisateur (Sans Assistant)

  1. Collecte des Ã‰chantillons Audio (CRITIQUE)

  1.1 Sources RecommandÃ©es

  - Haramain Recordings (site officiel des Deux Saintes MosquÃ©es)
  - Masjid Al-Haram (enregistrements officiels)
  - Islamic Audio Library (avec permissions)
  - YouTube (vÃ©rifier droits d'usage)

  1.2 CritÃ¨res de SÃ©lection Audio

  âœ… OBLIGATOIRE pour chaque rÃ©citateur:
  - DurÃ©e: 15-25 secondes de rÃ©citation continue
  - QualitÃ©: Enregistrement studio ou mosquÃ©e (sans Ã©cho)
  - Contenu: Versets avec Tajweed clair et correct
  - Format: MP3/WAV haute qualitÃ© (â‰¥128kbps)
  - Langue: Arabe classique (Fusha)
  - Silence: Pas de fond musical ou bruit parasite

  ğŸ¯ IDÃ‰AL:
  - RÃ©citation de sourates courtes (Al-Fatiha, Al-Ikhlas, Al-Falaq)
  - Tempo modÃ©rÃ© (ni trop rapide, ni trop lent)
  - Voix claire sans fatigue
  - Respect du Waqf (pauses appropriÃ©es)

  1.3 Structure des Fichiers Ã  PrÃ©parer

  audio_samples/
  â”œâ”€â”€ source/
  â”‚   â”œâ”€â”€ mishary_rashid_original.mp3
  â”‚   â”œâ”€â”€ sudais_original.mp3
  â”‚   â”œâ”€â”€ hudhaify_original.mp3
  â”‚   â””â”€â”€ afif_taj_original.mp3
  â””â”€â”€ metadata.txt  # Notes sur sources et droits

  2. PrÃ©paration du Corpus de Test

  2.1 Textes de Validation (Format UTF-8)

  CrÃ©er test_corpus.json:
  {
    "validation_texts": [
      {
        "id": "fatiha_1",
        "arabic": "Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø§Ù„Ø±ÙÙ‘Ø­Ù’Ù…ÙÙ°Ù†Ù Ø§Ù„Ø±ÙÙ‘Ø­ÙÙŠÙ…Ù",
        "transliteration": "Bismillahi ar-Rahmani ar-Raheem",
        "tajweed_rules": ["Basmalah", "Madd_Tabii", "Qalqalah"]
      },
      {
        "id": "fatiha_2",
        "arabic": "Ø§Ù„Ù’Ø­ÙÙ…Ù’Ø¯Ù Ù„ÙÙ„ÙÙ‘Ù‡Ù Ø±ÙØ¨ÙÙ‘ Ø§Ù„Ù’Ø¹ÙØ§Ù„ÙÙ…ÙÙŠÙ†Ù",
        "transliteration": "Alhamdu lillahi rabbi al-alameen",
        "tajweed_rules": ["Madd_Tabii", "Lam_Shamsiyyah"]
      },
      {
        "id": "ikhlas_1",
        "arabic": "Ù‚ÙÙ„Ù’ Ù‡ÙÙˆÙ Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø£ÙØ­ÙØ¯ÙŒ",
        "transliteration": "Qul huwa Allahu ahad",
        "tajweed_rules": ["Qalqalah", "Sukun", "Tanween"]
      },
      {
        "id": "complex_ayah",
        "arabic": "ÙˆÙØ§Ù„Ù’Ø¹ÙØ§Ø¯ÙÙŠÙØ§ØªÙ Ø¶ÙØ¨Ù’Ø­Ù‹Ø§",
        "transliteration": "Wal-adiyati dabha",
        "tajweed_rules": ["Waw_Sakt", "Idgham", "Tanween"]
      }
    ]
  }

  2.2 RÃ¨gles de Tajweed Ã  Documenter

  CrÃ©er tajweed_reference.md:
  # RÃ¨gles de Tajweed pour Validation

  ## RÃ¨gles Prioritaires Ã  Respecter:

  ### 1. Madd (Ø§Ù„Ù…Ø¯) - Prolongation
  - **Madd Tabii**: 2 temps (Ø­Ø±ÙˆÙ Ø§Ù„Ù…Ø¯)
  - **Madd Wajib**: 4-6 temps (avant Ù‡Ù…Ø²Ø©)
  - **Madd Layyin**: 2-4-6 temps selon contexte

  ### 2. Qalqalah (Ø§Ù„Ù‚Ù„Ù‚Ù„Ø©) - Vibration
  - Lettres: Ù‚ Ø· Ø¨ Ø¬ Ø¯
  - Forte en fin de mot
  - Faible en milieu de mot

  ### 3. Ghunna (Ø§Ù„ØºÙ†Ø©) - Nasalisation
  - DurÃ©e: 2 temps
  - Lettres: Ù… Ù† dans certains cas

  ### 4. Idgham (Ø§Ù„Ø¥Ø¯ØºØ§Ù…) - Fusion
  - Avec Ghunna: ÙŠ Ù† Ù… Ùˆ
  - Sans Ghunna: Ù„ Ø±

  ### 5. Waqf (Ø§Ù„ÙˆÙ‚Ù) - Pauses
  - Respecter les signes de ponctuation coranique
  - Pauses appropriÃ©es selon le sens

  3. AccÃ¨s Serveur VPS

  3.1 Informations de Connexion Ã  Fournir

  # IP du serveur
  IP_SERVER="168.231.112.71"

  # Port SSH (si diffÃ©rent de 22)
  SSH_PORT="22"

  # Utilisateur avec droits sudo
  USERNAME="votre_user"

  # Mot de passe ou clÃ© SSH
  # (Ne PAS documenter ici - transmettre sÃ©parÃ©ment)

  # RÃ©pertoire de travail Coqui existant
  COQUI_DIR="/var/coqui"  # Ã€ confirmer

  3.2 Test de ConnectivitÃ©

  # Tester la connexion SSH
  ssh -p 22 username@168.231.112.71 "echo 'Connexion OK'"

  # VÃ©rifier l'Ã©tat du service Coqui actuel
  ssh username@168.231.112.71 "sudo systemctl status coqui-tts"

  # VÃ©rifier l'espace disque
  ssh username@168.231.112.71 "df -h"

  4. Backup PrÃ©requis

  4.1 Sauvegarde du SystÃ¨me Actuel

  # CrÃ©er un backup complet avant modifications
  ssh username@168.231.112.71 "
  sudo systemctl stop coqui-tts
  sudo cp -r /var/coqui /var/coqui_backup_$(date +%Y%m%d_%H%M)
  sudo systemctl start coqui-tts
  "

  4.2 Point de Restauration

  Documenter la procÃ©dure de rollback:
  # En cas de problÃ¨me, restaurer avec:
  sudo systemctl stop coqui-tts
  sudo rm -rf /var/coqui
  sudo mv /var/coqui_backup_YYYYMMDD_HHMM /var/coqui
  sudo systemctl start coqui-tts

  ---
  ğŸ¤– Actions Assistant (Via IP Serveur)

  1. PrÃ©paration de l'Environnement

  1.1 Installation des DÃ©pendances Python

  # Mise Ã  jour du systÃ¨me
  sudo apt update && sudo apt upgrade -y

  # Installation des bibliothÃ¨ques audio
  sudo apt install -y ffmpeg sox libsox-fmt-all portaudio19-dev

  # Mise Ã  jour de TTS vers la derniÃ¨re version
  pip3 install --upgrade TTS torch torchaudio

  # Installation des dÃ©pendances pour le traitement audio
  pip3 install pydub librosa soundfile

  1.2 Structure des RÃ©pertoires

  # CrÃ©er l'arborescence pour les voix coraniques
  sudo mkdir -p
  /var/coqui/quranic_voices/{mishary_rashid,sudais,hudhaify,afif_taj}
  sudo mkdir -p /var/coqui/quranic_voices/{source,processed,cache}
  sudo mkdir -p /var/coqui/quranic_voices/scripts
  sudo mkdir -p /var/coqui/quranic_voices/tests

  # Permissions appropriÃ©es
  sudo chown -R coqui:coqui /var/coqui/quranic_voices
  sudo chmod -R 755 /var/coqui/quranic_voices

  2. Scripts de Traitement Audio

  2.1 PrÃ©parateur d'Ã‰chantillons Vocaux

  CrÃ©er /var/coqui/quranic_voices/scripts/prepare_voices.py:
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  PrÃ©parateur d'Ã©chantillons vocaux pour rÃ©citateurs coraniques
  Respecte les spÃ©cifications XTTS-v2 et les rÃ¨gles de Tajweed
  """

  import os
  import torch
  import torchaudio
  from pydub import AudioSegment
  import numpy as np
  import argparse
  import json
  from pathlib import Path

  class QuranicVoicePreparer:
      def __init__(self, base_dir="/var/coqui/quranic_voices"):
          self.base_dir = Path(base_dir)
          self.target_sr = 22050  # FrÃ©quence optimale pour XTTS-v2
          self.target_duration = 15  # DurÃ©e cible en secondes

          # Configuration des rÃ©citateurs avec leurs caractÃ©ristiques
          self.reciters_config = {
              "mishary_rashid": {
                  "name": "Mishary Rashid Alafasy",
                  "name_arabic": "Ù…Ø´Ø§Ø±ÙŠ Ø±Ø§Ø´Ø¯ Ø§Ù„Ø¹ÙØ§Ø³ÙŠ",
                  "speed_factor": 0.85,
                  "pitch_optimal": "medium-low",
                  "tajweed_style": "classical"
              },
              "sudais": {
                  "name": "Abdul Rahman As-Sudais",
                  "name_arabic": "Ø¹Ø¨Ø¯ Ø§Ù„Ø±Ø­Ù…Ù† Ø§Ù„Ø³Ø¯ÙŠØ³",
                  "speed_factor": 0.80,
                  "pitch_optimal": "medium",
                  "tajweed_style": "madinah"
              },
              "hudhaify": {
                  "name": "Ali Al-Hudhaify",
                  "name_arabic": "Ø¹Ù„ÙŠ Ø§Ù„Ø­Ø°ÙŠÙÙŠ",
                  "speed_factor": 0.90,
                  "pitch_optimal": "medium-high",
                  "tajweed_style": "classical"
              },
              "afif_taj": {
                  "name": "Afif Mohammed Taj",
                  "name_arabic": "Ø¹ÙÙŠÙ Ù…Ø­Ù…Ø¯ ØªØ§Ø¬",
                  "speed_factor": 0.88,
                  "pitch_optimal": "medium",
                  "tajweed_style": "modern"
              }
          }

      def analyze_audio_quality(self, audio_path):
          """
          Analyser la qualitÃ© audio pour validation Tajweed
          """
          try:
              audio = AudioSegment.from_file(audio_path)

              # MÃ©triques de base
              metrics = {
                  "duration_seconds": len(audio) / 1000.0,
                  "sample_rate": audio.frame_rate,
                  "channels": audio.channels,
                  "bit_depth": audio.sample_width * 8,
                  "average_dBFS": audio.dBFS,
                  "max_dBFS": audio.max_dBFS,
                  "rms_dBFS": audio.rms
              }

              # Validation pour rÃ©citation coranique
              quality_issues = []

              if metrics["duration_seconds"] < 10:
                  quality_issues.append("DurÃ©e trop courte (< 10s)")
              if metrics["duration_seconds"] > 30:
                  quality_issues.append("DurÃ©e trop longue (> 30s)")
              if metrics["sample_rate"] < 16000:
                  quality_issues.append("FrÃ©quence d'Ã©chantillonnage trop 
  basse")
              if metrics["average_dBFS"] < -30:
                  quality_issues.append("Volume trop faible")
              if metrics["max_dBFS"] > -3:
                  quality_issues.append("Risque de saturation")

              metrics["quality_issues"] = quality_issues
              metrics["suitable_for_xtts"] = len(quality_issues) == 0

              return metrics

          except Exception as e:
              return {"error": str(e)}

      def extract_optimal_segment(self, source_path, reciter_id, 
  start_offset=5):
          """
          Extraire le segment optimal pour XTTS-v2
          Prend en compte les rÃ¨gles de Tajweed
          """

          if reciter_id not in self.reciters_config:
              raise ValueError(f"RÃ©citateur {reciter_id} non reconnu")

          config = self.reciters_config[reciter_id]

          # Charger et analyser l'audio source
          audio = AudioSegment.from_file(source_path)
          total_duration = len(audio) / 1000.0

          print(f"ğŸ¤ Traitement: {config['name']} 
  ({config['name_arabic']})")
          print(f"ğŸ“Š Audio source: {total_duration:.1f}s, 
  {audio.frame_rate}Hz, {audio.channels}ch")

          # DÃ©terminer le meilleur segment
          if total_duration < self.target_duration:
              print("âš ï¸  Audio source plus court que la durÃ©e cible")
              segment = audio
              actual_start = 0
          else:
              # Ã‰viter le dÃ©but (souvent silence ou Ta'awwudh)
              # et la fin (possible coupure)
              safe_start = max(start_offset, total_duration * 0.1)
              safe_end = total_duration * 0.9
              available_duration = safe_end - safe_start

              if available_duration >= self.target_duration:
                  # Choisir un segment au milieu pour avoir du Tajweed 
  fluide
                  segment_start = safe_start + (available_duration -
  self.target_duration) / 2
                  actual_start = segment_start
              else:
                  segment_start = safe_start
                  actual_start = segment_start

              start_ms = int(segment_start * 1000)
              end_ms = min(start_ms + (self.target_duration * 1000),
  len(audio))
              segment = audio[start_ms:end_ms]

          # Optimisations pour XTTS-v2
          # 1. Convertir en mono
          if segment.channels > 1:
              segment = segment.set_channels(1)
              print("ğŸ”„ Conversion en mono")

          # 2. Ajuster la frÃ©quence d'Ã©chantillonnage
          if segment.frame_rate != self.target_sr:
              segment = segment.set_frame_rate(self.target_sr)
              print(f"ğŸ”„ Resampling vers {self.target_sr}Hz")

          # 3. Normalisation douce (prÃ©server la dynamique du Tajweed)
          target_dBFS = -20.0  # Volume optimal pour la parole
          gain_needed = target_dBFS - segment.dBFS
          if abs(gain_needed) > 1.0:  # Ajuster seulement si nÃ©cessaire
              segment = segment + gain_needed
              print(f"ğŸ”„ Normalisation: {gain_needed:+.1f}dB")

          # 4. RÃ©duction lÃ©gÃ¨re du bruit (prÃ©server la qualitÃ© vocale)
          # Appliquer un filtre passe-haut lÃ©ger pour rÃ©duire les basses 
  frÃ©quences
          segment = segment.high_pass_filter(80)

          # 5. Fade in/out pour Ã©viter les clics
          segment = segment.fade_in(50).fade_out(50)

          # Sauvegarder le segment traitÃ©
          output_dir = self.base_dir / reciter_id
          output_dir.mkdir(exist_ok=True)

          output_path = output_dir / "sample.wav"
          segment.export(str(output_path), format="wav")

          # MÃ©tadonnÃ©es de traitement
          metadata = {
              "reciter": config,
              "source_file": str(source_path),
              "segment_start_seconds": actual_start,
              "segment_duration_seconds": len(segment) / 1000.0,
              "processing_date": str(datetime.now()),
              "xtts_optimized": True,
              "quality_metrics":
  self.analyze_audio_quality(str(output_path))
          }

          # Sauvegarder les mÃ©tadonnÃ©es
          metadata_path = output_dir / "metadata.json"
          with open(metadata_path, 'w', encoding='utf-8') as f:
              json.dump(metadata, f, indent=2, ensure_ascii=False)

          print(f"âœ… Ã‰chantillon crÃ©Ã©: {output_path}")
          print(f"ğŸ“ MÃ©tadonnÃ©es: {metadata_path}")
          print(f"â±ï¸  DurÃ©e finale: {len(segment)/1000:.1f}s")

          return str(output_path), metadata

      def validate_tajweed_compatibility(self, audio_path):
          """
          Validation spÃ©cifique pour la rÃ©citation coranique
          """
          try:
              waveform, sample_rate = torchaudio.load(audio_path)

              # Analyse spectrale pour dÃ©tecter les caractÃ©ristiques du 
  Tajweed
              spectrogram = torchaudio.transforms.Spectrogram()(waveform)

              validation_results = {
                  "spectral_clarity": True,  # Ã€ implÃ©menter avec analyse 
  FFT
                  "dynamic_range_adequate": True,  # Variation pour Madd, 
  Qalqalah
                  "frequency_response_balanced": True,  # Pas de coupure 
  dans les graves/aigus
                  "duration_appropriate": 10 <= len(waveform[0]) /
  sample_rate <= 25,
                  "no_clipping": torch.max(torch.abs(waveform)) < 0.95
              }

              validation_results["overall_suitable"] =
  all(validation_results.values())

              return validation_results

          except Exception as e:
              return {"error": str(e), "overall_suitable": False}

      def process_all_reciters(self, source_dir):
          """
          Traiter tous les rÃ©citateurs d'un coup
          """
          source_path = Path(source_dir)
          results = {}

          for reciter_id in self.reciters_config.keys():
              # Chercher le fichier source
              possible_files = [
                  source_path / f"{reciter_id}_original.mp3",
                  source_path / f"{reciter_id}_original.wav",
                  source_path / f"{reciter_id}.mp3",
                  source_path / f"{reciter_id}.wav"
              ]

              source_file = None
              for pf in possible_files:
                  if pf.exists():
                      source_file = pf
                      break

              if source_file:
                  try:
                      print(f"\nğŸ¯ Traitement de {reciter_id}...")
                      output_path, metadata = self.extract_optimal_segment(
                          str(source_file),
                          reciter_id
                      )

                      # Validation Tajweed
                      validation =
  self.validate_tajweed_compatibility(output_path)
                      metadata["tajweed_validation"] = validation

                      results[reciter_id] = {
                          "status": "success",
                          "output_path": output_path,
                          "metadata": metadata
                      }

                      if validation["overall_suitable"]:
                          print(f"âœ… {reciter_id}: PrÃªt pour XTTS-v2")
                      else:
                          print(f"âš ï¸  {reciter_id}: ProblÃ¨mes dÃ©tectÃ©s, 
  vÃ©rification manuelle recommandÃ©e")

                  except Exception as e:
                      print(f"âŒ Erreur pour {reciter_id}: {e}")
                      results[reciter_id] = {
                          "status": "error",
                          "error": str(e)
                      }
              else:
                  print(f"âŒ Fichier source non trouvÃ© pour {reciter_id}")
                  results[reciter_id] = {
                      "status": "missing_source",
                      "searched_files": [str(p) for p in possible_files]
                  }

          # Rapport final
          print(f"\nğŸ“‹ RAPPORT DE TRAITEMENT")
          print("=" * 50)

          successful = 0
          for reciter_id, result in results.items():
              status_emoji = {
                  "success": "âœ…",
                  "error": "âŒ",
                  "missing_source": "ğŸ“"
              }.get(result["status"], "â“")

              print(f"{status_emoji} {reciter_id}: {result['status']}")

              if result["status"] == "success":
                  successful += 1

          print(f"\nğŸ¯ RÃ©sultat: {successful}/{len(self.reciters_config)} 
  rÃ©citateurs traitÃ©s avec succÃ¨s")

          return results

  if __name__ == "__main__":
      import datetime
      from datetime import datetime

      parser = argparse.ArgumentParser(description="PrÃ©parer les 
  Ã©chantillons vocaux pour rÃ©citateurs coraniques")
      parser.add_argument("--source-dir", required=True, help="RÃ©pertoire 
  contenant les fichiers audio sources")
      parser.add_argument("--reciter", help="Traiter un rÃ©citateur 
  spÃ©cifique seulement")
      parser.add_argument("--analyze-only", action="store_true",
  help="Analyser la qualitÃ© sans traitement")

      args = parser.parse_args()

      preparer = QuranicVoicePreparer()

      if args.reciter:
          # Traiter un seul rÃ©citateur
          source_files =
  list(Path(args.source_dir).glob(f"{args.reciter}*"))
          if source_files:
              try:
                  output_path, metadata = preparer.extract_optimal_segment(
                      str(source_files[0]),
                      args.reciter
                  )
                  print(f"âœ… Traitement terminÃ©: {output_path}")
              except Exception as e:
                  print(f"âŒ Erreur: {e}")
          else:
              print(f"âŒ Aucun fichier trouvÃ© pour {args.reciter}")
      else:
          # Traiter tous les rÃ©citateurs
          results = preparer.process_all_reciters(args.source_dir)

  2.2 Service XTTS-v2 pour RÃ©citation Coranique

  CrÃ©er /var/coqui/quranic_voices/scripts/quranic_xtts_service.py:
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  Service XTTS-v2 optimisÃ© pour la rÃ©citation coranique
  IntÃ¨gre les rÃ¨gles de Tajweed et les optimisations de voix
  """

  import os
  import torch
  import torchaudio
  import json
  import time
  import gc
  from pathlib import Path
  from typing import Dict, Optional, List, Tuple
  from TTS.api import TTS
  import numpy as np

  class QuranicXTTSService:
      def __init__(self, base_dir="/var/coqui/quranic_voices", 
  low_memory_mode=True):
          self.base_dir = Path(base_dir)
          self.low_memory_mode = low_memory_mode
          self.device = "cuda" if torch.cuda.is_available() else "cpu"

          print(f"ğŸ¯ Initialisation QuranicXTTSService")
          print(f"ğŸ“± Device: {self.device}")
          print(f"ğŸ’¾ Mode mÃ©moire: {'Ã‰conomique' if low_memory_mode else 
  'Performance'}")

          # Optimisations mÃ©moire pour VPS
          if self.low_memory_mode and self.device == "cpu":
              torch.set_num_threads(2)
              torch.set_grad_enabled(False)

          # Charger le modÃ¨le XTTS-v2
          self.tts = None
          self.load_model()

          # Configuration des rÃ©citateurs avec paramÃ¨tres Tajweed
          self.reciters_config = self._load_reciters_config()

          # Cache pour optimiser les performances
          self.voice_embeddings_cache = {}

          print(f"âœ… Service initialisÃ© avec {len(self.reciters_config)} 
  rÃ©citateurs")

      def _load_reciters_config(self) -> Dict:
          """
          Charger la configuration des rÃ©citateurs avec paramÃ¨tres de 
  Tajweed
          """
          config = {
              "mishary_rashid": {
                  "name": "Mishary Rashid Alafasy",
                  "name_arabic": "Ù…Ø´Ø§Ø±ÙŠ Ø±Ø§Ø´Ø¯ Ø§Ù„Ø¹ÙØ§Ø³ÙŠ",
                  "sample_path": str(self.base_dir / "mishary_rashid" /
  "sample.wav"),
                  "voice_characteristics": {
                      "pitch_range": "medium-low",
                      "speed_base": 0.85,
                      "clarity_level": "high",
                      "tajweed_style": "classical"
                  },
                  "synthesis_params": {
                      "temperature": 0.5,      # StabilitÃ© de la voix
                      "top_p": 0.85,          # DiversitÃ© contrÃ´lÃ©e
                      "top_k": 50,            # Limitation du vocabulaire
                      "repetition_penalty": 1.1,
                      "length_penalty": 1.0
                  },
                  "tajweed_adjustments": {
                      "madd_emphasis": 1.2,    # Accentuation des 
  prolongations
                      "qalqalah_strength": 1.1, # Force des vibrations
                      "ghunna_duration": 1.0,   # DurÃ©e de nasalisation
                      "waqf_pause_factor": 1.0  # Facteur de pause
                  }
              },
              "sudais": {
                  "name": "Abdul Rahman As-Sudais",
                  "name_arabic": "Ø¹Ø¨Ø¯ Ø§Ù„Ø±Ø­Ù…Ù† Ø§Ù„Ø³Ø¯ÙŠØ³",
                  "sample_path": str(self.base_dir / "sudais" /
  "sample.wav"),
                  "voice_characteristics": {
                      "pitch_range": "medium",
                      "speed_base": 0.80,
                      "clarity_level": "very_high",
                      "tajweed_style": "madinah"
                  },
                  "synthesis_params": {
                      "temperature": 0.45,
                      "top_p": 0.80,
                      "top_k": 50,
                      "repetition_penalty": 1.2,
                      "length_penalty": 1.0
                  },
                  "tajweed_adjustments": {
                      "madd_emphasis": 1.3,
                      "qalqalah_strength": 1.2,
                      "ghunna_duration": 1.1,
                      "waqf_pause_factor": 1.2
                  }
              },
              "hudhaify": {
                  "name": "Ali Al-Hudhaify",
                  "name_arabic": "Ø¹Ù„ÙŠ Ø§Ù„Ø­Ø°ÙŠÙÙŠ",
                  "sample_path": str(self.base_dir / "hudhaify" /
  "sample.wav"),
                  "voice_characteristics": {
                      "pitch_range": "medium-high",
                      "speed_base": 0.90,
                      "clarity_level": "high",
                      "tajweed_style": "classical"
                  },
                  "synthesis_params": {
                      "temperature": 0.5,
                      "top_p": 0.85,
                      "top_k": 50,
                      "repetition_penalty": 1.1,
                      "length_penalty": 1.0
                  },
                  "tajweed_adjustments": {
                      "madd_emphasis": 1.1,
                      "qalqalah_strength": 1.0,
                      "ghunna_duration": 0.9,
                      "waqf_pause_factor": 1.1
                  }
              },
              "afif_taj": {
                  "name": "Afif Mohammed Taj",
                  "name_arabic": "Ø¹ÙÙŠÙ Ù…Ø­Ù…Ø¯ ØªØ§Ø¬",
                  "sample_path": str(self.base_dir / "afif_taj" /
  "sample.wav"),
                  "voice_characteristics": {
                      "pitch_range": "medium",
                      "speed_base": 0.88,
                      "clarity_level": "high",
                      "tajweed_style": "modern"
                  },
                  "synthesis_params": {
                      "temperature": 0.55,
                      "top_p": 0.85,
                      "top_k": 50,
                      "repetition_penalty": 1.1,
                      "length_penalty": 1.0
                  },
                  "tajweed_adjustments": {
                      "madd_emphasis": 1.15,
                      "qalqalah_strength": 1.05,
                      "ghunna_duration": 1.0,
                      "waqf_pause_factor": 1.0
                  }
              }
          }

          # VÃ©rifier que les Ã©chantillons existent
          available_reciters = {}
          for reciter_id, config_data in config.items():
              sample_path = config_data["sample_path"]
              if os.path.exists(sample_path):
                  available_reciters[reciter_id] = config_data
                  print(f"âœ… {reciter_id}: Ã‰chantillon trouvÃ©")
              else:
                  print(f"âŒ {reciter_id}: Ã‰chantillon manquant - 
  {sample_path}")

          return available_reciters

      def load_model(self):
          """
          Charger le modÃ¨le XTTS-v2 avec optimisations
          """
          if self.tts is None:
              print("â³ Chargement du modÃ¨le XTTS-v2...")
              start_time = time.time()

              try:
                  self.tts =
  TTS("tts_models/multilingual/multi-dataset/xtts_v2")

                  # Optimisations mÃ©moire
                  if self.low_memory_mode:
                      if hasattr(self.tts.synthesizer.tts_model, 'half'):
                          self.tts.synthesizer.tts_model.half()
                          print("ğŸ”§ Mode FP16 activÃ©")

                  self.tts.to(self.device)

                  load_time = time.time() - start_time
                  print(f"âœ… ModÃ¨le chargÃ© en {load_time:.1f}s")

              except Exception as e:
                  print(f"âŒ Erreur chargement modÃ¨le: {e}")
                  raise

      def unload_model(self):
          """
          LibÃ©rer la mÃ©moire du modÃ¨le
          """
          if self.tts:
              del self.tts
              self.tts = None
              self.voice_embeddings_cache.clear()
              gc.collect()

              if self.device == "cuda":
                  torch.cuda.empty_cache()

              print("ğŸ—‘ï¸  ModÃ¨le dÃ©chargÃ© de la mÃ©moire")

      def precompute_voice_embedding(self, reciter_id: str) -> bool:
          """
          PrÃ©-calculer l'embedding vocal pour accÃ©lÃ©rer la synthÃ¨se
          """
          if reciter_id not in self.reciters_config:
              return False

          if reciter_id in self.voice_embeddings_cache:
              return True

          try:
              config = self.reciters_config[reciter_id]
              sample_path = config["sample_path"]

              print(f"ğŸ¤ PrÃ©-calcul embedding pour {config['name']}...")

              # Charger et traiter l'Ã©chantillon
              if self.tts:
                  # Cette Ã©tape calcule l'embedding et le met en cache dans
   XTTS
                  test_synthesis = self.tts.tts(
                      text="Ø§Ø®ØªØ¨Ø§Ø±",  # Test simple
                      speaker_wav=sample_path,
                      language="ar"
                  )

                  self.voice_embeddings_cache[reciter_id] = True
                  print(f"âœ… Embedding calculÃ© pour {reciter_id}")
                  return True

          except Exception as e:
              print(f"âŒ Erreur prÃ©-calcul {reciter_id}: {e}")
              return False

      def precompute_all_embeddings(self):
          """
          PrÃ©-calculer tous les embeddings disponibles
          """
          print("ğŸ¯ PrÃ©-calcul de tous les embeddings vocaux...")

          successful = 0
          for reciter_id in self.reciters_config.keys():
              if self.precompute_voice_embedding(reciter_id):
                  successful += 1

          print(f"âœ… {successful}/{len(self.reciters_config)} embeddings 
  prÃ©-calculÃ©s")
          return successful

      def apply_tajweed_processing(self, text: str, reciter_id: str) -> 
  str:
          """
          Appliquer un prÃ©-traitement du texte selon les rÃ¨gles de Tajweed
          """
          if reciter_id not in self.reciters_config:
              return text

          adjustments =
  self.reciters_config[reciter_id]["tajweed_adjustments"]
          processed_text = text

          # Marquer les lettres de Qalqalah pour emphase
          qalqalah_letters = ['Ù‚', 'Ø·', 'Ø¨', 'Ø¬', 'Ø¯']
          for letter in qalqalah_letters:
              if letter in processed_text:
                  # Ajouter une micro-pause aprÃ¨s pour simuler la vibration
                  processed_text = processed_text.replace(letter,
  f"{letter}â€ ")

          # Marquer les Madd pour prolongation
          madd_patterns = ['Ø¢', 'Ø§', 'Ùˆ', 'ÙŠ']
          for pattern in madd_patterns:
              if pattern in processed_text and adjustments["madd_emphasis"]
   > 1.0:
                  # Ajouter des marqueurs de prolongation
                  processed_text = processed_text.replace(pattern,
  f"{pattern}Ë")

          return processed_text.strip()

      def synthesize_ayah(self, 
                         text: str, 
                         reciter: str = "mishary_rashid",
                         apply_tajweed: bool = True,
                         output_path: Optional[str] = None) -> 
  Optional[np.ndarray]:
          """
          SynthÃ©tiser une ayah avec la voix d'un rÃ©citateur
          """

          if reciter not in self.reciters_config:
              available = ", ".join(self.reciters_config.keys())
              raise ValueError(f"RÃ©citateur '{reciter}' non disponible. 
  Disponibles: {available}")

          config = self.reciters_config[reciter]
          sample_path = config["sample_path"]

          # VÃ©rifier que l'Ã©chantillon existe
          if not os.path.exists(sample_path):
              raise FileNotFoundError(f"Ã‰chantillon manquant: 
  {sample_path}")

          # S'assurer que le modÃ¨le est chargÃ©
          if self.tts is None:
              self.load_model()

          print(f"ğŸ™ï¸  SynthÃ¨se avec {config['name']} 
  ({config['name_arabic']})")
          print(f"ğŸ“ Texte: {text[:50]}{'...' if len(text) > 50 else ''}")

          try:
              # PrÃ©-traitement Tajweed si demandÃ©
              processed_text = self.apply_tajweed_processing(text, reciter)
   if apply_tajweed else text

              # ParamÃ¨tres de synthÃ¨se
              synthesis_params = config["synthesis_params"].copy()
              synthesis_params.update({
                  "text": processed_text,
                  "speaker_wav": sample_path,
                  "language": "ar",
                  "speed": config["voice_characteristics"]["speed_base"]
              })

              start_time = time.time()

              # SynthÃ¨se avec gestion mÃ©moire
              with torch.no_grad():
                  if output_path:
                      self.tts.tts_to_file(
                          file_path=output_path,
                          **synthesis_params
                      )
                      synthesis_time = time.time() - start_time
                      print(f"âœ… Audio sauvegardÃ©: {output_path} 
  ({synthesis_time:.1f}s)")
                      return output_path
                  else:
                      wav_data = self.tts.tts(**synthesis_params)
                      synthesis_time = time.time() - start_time
                      print(f"âœ… SynthÃ¨se terminÃ©e en 
  {synthesis_time:.1f}s")
                      return wav_data

          except Exception as e:
              print(f"âŒ Erreur synthÃ¨se {reciter}: {e}")
              return None
          finally:
              # Nettoyage mÃ©moire si mode Ã©conomique
              if self.low_memory_mode:
                  gc.collect()

      def batch_synthesize_surah(self, 
                                ayat_list: List[str], 
                                reciter: str = "mishary_rashid",
                                output_dir: Optional[str] = None) -> 
  List[str]:
          """
          SynthÃ©tiser une sourate complÃ¨te (liste d'ayat)
          """

          if output_dir:
              output_path = Path(output_dir)
              output_path.mkdir(parents=True, exist_ok=True)
          else:
              output_path = self.base_dir / "output" / reciter
              output_path.mkdir(parents=True, exist_ok=True)

          print(f"ğŸ“– SynthÃ¨se de {len(ayat_list)} ayat avec {reciter}")

          results = []
          successful = 0

          for i, ayah in enumerate(ayat_list, 1):
              try:
                  filename = f"ayah_{i:03d}.wav"
                  file_path = output_path / filename

                  print(f"\nğŸ¯ Ayah {i}/{len(ayat_list)}")

                  result = self.synthesize_ayah(
                      text=ayah,
                      reciter=reciter,
                      output_path=str(file_path)
                  )

                  if result:
                      results.append(str(file_path))
                      successful += 1
                  else:
                      results.append(None)

              except Exception as e:
                  print(f"âŒ Erreur ayah {i}: {e}")
                  results.append(None)

          print(f"\nğŸ“Š RÃ©sultat: {successful}/{len(ayat_list)} ayat 
  synthÃ©tisÃ©es avec succÃ¨s")
          return results

      def get_available_reciters(self) -> Dict[str, Dict]:
          """
          Retourner la liste des rÃ©citateurs disponibles avec leurs 
  informations
          """
          return {
              reciter_id: {
                  "name": config["name"],
                  "name_arabic": config["name_arabic"],
                  "style":
  config["voice_characteristics"]["tajweed_style"],
                  "available": os.path.exists(config["sample_path"])
              }
              for reciter_id, config in self.reciters_config.items()
          }

      def validate_setup(self) -> Dict[str, bool]:
          """
          Valider que tout est correctement configurÃ©
          """
          validation = {
              "model_loaded": self.tts is not None,
              "device_available": True,
              "reciters_available": len(self.reciters_config) > 0,
              "samples_exist": all(
                  os.path.exists(config["sample_path"])
                  for config in self.reciters_config.values()
              )
          }

          validation["overall_ready"] = all(validation.values())

          return validation

  if __name__ == "__main__":
      # Test du service
      service = QuranicXTTSService()

      # Validation
      validation = service.validate_setup()
      print(f"\nğŸ” VALIDATION DU SERVICE")
      print("=" * 40)
      for check, status in validation.items():
          emoji = "âœ…" if status else "âŒ"
          print(f"{emoji} {check}: {status}")

      if validation["overall_ready"]:
          print(f"\nğŸ¯ Service prÃªt pour utilisation!")

          # Test simple avec Al-Fatiha
          print(f"\nğŸ§ª Test de synthÃ¨se...")

          test_ayah = "Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø§Ù„Ø±ÙÙ‘Ø­Ù’Ù…ÙÙ°Ù†Ù Ø§Ù„Ø±ÙÙ‘Ø­ÙÙŠÙ…Ù"

          for reciter in list(service.reciters_config.keys())[:2]:  # 
  Tester 2 rÃ©citateurs
              try:
                  output_file = f"/tmp/test_{reciter}.wav"
                  result = service.synthesize_ayah(
                      text=test_ayah,
                      reciter=reciter,
                      output_path=output_file
                  )

                  if result and os.path.exists(output_file):
                      file_size = os.path.getsize(output_file)
                      print(f"âœ… Test {reciter}: {file_size} bytes")
                  else:
                      print(f"âŒ Test {reciter}: Ã‰chec")

              except Exception as e:
                  print(f"âŒ Test {reciter}: {e}")
      else:
          print(f"\nâŒ Service non prÃªt - Corriger les problÃ¨mes 
  ci-dessus")

  3. IntÃ©gration API

  3.1 Extension de l'API Existante

  Modifier /var/coqui/main.py (ou crÃ©er un nouveau fichier):
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  API Coqui TTS Ã©tendue pour la rÃ©citation coranique
  Compatible avec l'implÃ©mentation Flutter existante
  """

  from fastapi import FastAPI, HTTPException, UploadFile, File
  from fastapi.responses import FileResponse, JSONResponse
  from fastapi.middleware.cors import CORSMiddleware
  from pydantic import BaseModel, Field
  from typing import Optional, List, Dict
  import os
  import sys
  import base64
  import hashlib
  import time
  from pathlib import Path

  # Ajouter le chemin des scripts
  sys.path.append('/var/coqui/quranic_voices/scripts')

  try:
      from quranic_xtts_service import QuranicXTTSService
      QURANIC_SERVICE_AVAILABLE = True
  except ImportError:
      QURANIC_SERVICE_AVAILABLE = False
      print("âš ï¸  Service coranique non disponible")

  # Configuration
  app = FastAPI(
      title="Coqui TTS API with Quranic Voices",
      description="TTS API avec support pour rÃ©citateurs coraniques",
      version="2.0.0"
  )

  # CORS pour Flutter
  app.add_middleware(
      CORSMiddleware,
      allow_origins=["*"],
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
  )

  # Service global
  quranic_service = None

  @app.on_event("startup")
  async def startup_event():
      """Initialiser les services au dÃ©marrage"""
      global quranic_service

      if QURANIC_SERVICE_AVAILABLE:
          try:
              print("ğŸ¯ Initialisation du service coranique...")
              quranic_service = QuranicXTTSService(low_memory_mode=True)

              validation = quranic_service.validate_setup()
              if validation["overall_ready"]:
                  print("âœ… Service coranique prÃªt")
                  # PrÃ©-calculer les embeddings pour de meilleures 
  performances
                  quranic_service.precompute_all_embeddings()
              else:
                  print("âš ï¸  Service coranique partiellement disponible")

          except Exception as e:
              print(f"âŒ Erreur initialisation service coranique: {e}")
              quranic_service = None

  # ModÃ¨les Pydantic
  class TTSRequest(BaseModel):
      text: str = Field(..., description="Texte Ã  synthÃ©tiser")
      language: str = Field(default="fr", description="Langue (ar, fr, 
  en)")
      voice_type: str = Field(default="male", description="Type de voix")
      rate: str = Field(default="+0%", description="Vitesse de parole")

  class QuranicTTSRequest(BaseModel):
      text: str = Field(..., description="Texte coranique Ã  rÃ©citer")
      reciter: str = Field(default="mishary_rashid", description="ID du 
  rÃ©citateur")
      apply_tajweed: bool = Field(default=True, description="Appliquer les 
  rÃ¨gles de Tajweed")
      rate: str = Field(default="+0%", description="Ajustement de vitesse")

  class BatchQuranicRequest(BaseModel):
      ayat_list: List[str] = Field(..., description="Liste des ayat Ã  
  synthÃ©tiser")
      reciter: str = Field(default="mishary_rashid", description="ID du 
  rÃ©citateur")
      surah_name: Optional[str] = Field(None, description="Nom de la 
  sourate")

  # ============= ENDPOINTS EXISTANTS (CompatibilitÃ©) =============

  @app.post("/api/tts")
  async def synthesize_standard(request: TTSRequest):
      """
      Endpoint TTS standard (compatible avec l'implÃ©mentation Flutter 
  existante)
      """
      try:
          # DÃ©tecter si c'est du texte coranique
          is_arabic = any('\u0600' <= char <= '\u06FF' for char in
  request.text)

          if is_arabic and quranic_service and
  len(quranic_service.reciters_config) > 0:
              # Rediriger vers le service coranique avec rÃ©citateur par 
  dÃ©faut
              print(f"ğŸ”„ Redirection vers service coranique pour texte 
  arabe")

              quranic_request = QuranicTTSRequest(
                  text=request.text,
                  reciter="mishary_rashid",  # RÃ©citateur par dÃ©faut
                  rate=request.rate
              )

              return await synthesize_quranic(quranic_request)

          else:
              # Service TTS standard pour les autres langues
              # TODO: ImplÃ©menter ou garder l'ancien service
              return {"error": "Service TTS standard non implÃ©mentÃ© dans 
  cette version"}

      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))

  # ============= NOUVEAUX ENDPOINTS CORANIQUES =============

  @app.post("/api/tts/quranic")
  async def synthesize_quranic(request: QuranicTTSRequest):
      """
      SynthÃ¨se TTS avec voix de rÃ©citateurs coraniques
      """
      if not quranic_service:
          raise HTTPException(
              status_code=503,
              detail="Service de rÃ©citation coranique non disponible"
          )

      try:
          # GÃ©nÃ©rer un nom de fichier unique
          text_hash = hashlib.md5(
              f"{request.text}_{request.reciter}_{request.rate}".encode()
          ).hexdigest()[:8]

          cache_dir = Path("/tmp/quranic_cache")
          cache_dir.mkdir(exist_ok=True)
          output_path = cache_dir / f"quranic_{text_hash}.wav"

          # Ajuster la vitesse selon le paramÃ¨tre rate
          speed_adjustment = 1.0
          if request.rate.startswith('+'):
              speed_adjustment = 1.0 + (int(request.rate[1:-1]) / 100.0)
          elif request.rate.startswith('-'):
              speed_adjustment = 1.0 - (int(request.rate[1:-1]) / 100.0)

          # SynthÃ©tiser
          result = quranic_service.synthesize_ayah(
              text=request.text,
              reciter=request.reciter,
              apply_tajweed=request.apply_tajweed,
              output_path=str(output_path)
          )

          if result and output_path.exists():
              # Lire et encoder en base64 (compatibilitÃ© avec Flutter)
              with open(output_path, 'rb') as audio_file:
                  audio_data = audio_file.read()
                  audio_b64 = base64.b64encode(audio_data).decode()

              # Nettoyer le fichier temporaire
              try:
                  output_path.unlink()
              except:
                  pass

              return {
                  "audio": audio_b64,
                  "reciter": request.reciter,
                  "tajweed_applied": request.apply_tajweed,
                  "synthesis_time": time.time()
              }
          else:
              raise HTTPException(status_code=500, detail="Ã‰chec de la 
  synthÃ¨se")

      except ValueError as e:
          raise HTTPException(status_code=400, detail=str(e))
      except Exception as e:
          raise HTTPException(status_code=500, detail=f"Erreur synthÃ¨se: 
  {e}")

  @app.post("/api/tts/quranic/batch")
  async def synthesize_batch_quranic(request: BatchQuranicRequest):
      """
      SynthÃ¨se de plusieurs ayat (sourate complÃ¨te)
      """
      if not quranic_service:
          raise HTTPException(
              status_code=503,
              detail="Service de rÃ©citation coranique non disponible"
          )

      try:
          # CrÃ©er un rÃ©pertoire temporaire pour cette batch
          batch_id = hashlib.md5(

  f"{str(request.ayat_list)}_{request.reciter}_{time.time()}".encode()
          ).hexdigest()[:8]

          output_dir = Path(f"/tmp/quranic_batch_{batch_id}")
          output_dir.mkdir(exist_ok=True)

          # SynthÃ©tiser tous les ayat
          results = quranic_service.batch_synthesize_surah(
              ayat_list=request.ayat_list,
              reciter=request.reciter,
              output_dir=str(output_dir)
          )

          # Compiler les rÃ©sultats
          batch_response = {
              "batch_id": batch_id,
              "reciter": request.reciter,
              "surah_name": request.surah_name,
              "total_ayat": len(request.ayat_list),
              "successful_ayat": len([r for r in results if r]),
              "files": []
          }

          for i, result_path in enumerate(results, 1):
              if result_path and os.path.exists(result_path):
                  # Encoder chaque fichier
                  with open(result_path, 'rb') as f:
                      audio_b64 = base64.b64encode(f.read()).decode()

                  batch_response["files"].append({
                      "ayah_number": i,
                      "audio": audio_b64,
                      "text": request.ayat_list[i-1]
                  })

          # Nettoyer les fichiers temporaires
          try:
              import shutil
              shutil.rmtree(output_dir)
          except:
              pass

          return batch_response

      except Exception as e:
          raise HTTPException(status_code=500, detail=f"Erreur batch: {e}")

  @app.get("/api/reciters")
  async def list_reciters():
      """
      Lister les rÃ©citateurs disponibles
      """
      if not quranic_service:
          return {"reciters": [], "message": "Service coranique non 
  disponible"}

      try:
          reciters = quranic_service.get_available_reciters()

          return {
              "reciters": reciters,
              "total": len(reciters),
              "service_status": "active"
          }

      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))

  @app.get("/api/reciters/{reciter_id}")
  async def get_reciter_info(reciter_id: str):
      """
      Informations dÃ©taillÃ©es sur un rÃ©citateur
      """
      if not quranic_service:
          raise HTTPException(status_code=503, detail="Service non 
  disponible")

      if reciter_id not in quranic_service.reciters_config:
          raise HTTPException(status_code=404, detail="RÃ©citateur non 
  trouvÃ©")

      config = quranic_service.reciters_config[reciter_id]

      return {
          "id": reciter_id,
          "name": config["name"],
          "name_arabic": config["name_arabic"],
          "voice_characteristics": config["voice_characteristics"],
          "available": os.path.exists(config["sample_path"]),
          "sample_exists": os.path.exists(config["sample_path"])
      }

  @app.post("/api/reciters/{reciter_id}/test")
  async def test_reciter(reciter_id: str):
      """
      Tester un rÃ©citateur avec la Basmalah
      """
      if not quranic_service:
          raise HTTPException(status_code=503, detail="Service non 
  disponible")

      test_request = QuranicTTSRequest(
          text="Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø§Ù„Ø±ÙÙ‘Ø­Ù’Ù…ÙÙ°Ù†Ù Ø§Ù„Ø±ÙÙ‘Ø­ÙÙŠÙ…Ù",
          reciter=reciter_id
      )

      return await synthesize_quranic(test_request)

  # ============= ENDPOINTS DE GESTION =============

  @app.get("/api/status")
  async def get_status():
      """
      Ã‰tat du service
      """
      status = {
          "service": "Coqui TTS avec voix coraniques",
          "version": "2.0.0",
          "quranic_service_available": quranic_service is not None,
          "timestamp": time.time()
      }

      if quranic_service:
          validation = quranic_service.validate_setup()
          status.update({
              "quranic_validation": validation,
              "available_reciters": len(quranic_service.reciters_config),
              "device": quranic_service.device
          })

      return status

  @app.post("/api/admin/reload")
  async def reload_quranic_service():
      """
      Recharger le service coranique (admin)
      """
      global quranic_service

      try:
          if quranic_service:
              quranic_service.unload_model()

          quranic_service = QuranicXTTSService(low_memory_mode=True)
          validation = quranic_service.validate_setup()

          return {
              "status": "reloaded",
              "validation": validation,
              "timestamp": time.time()
          }

      except Exception as e:
          raise HTTPException(status_code=500, detail=f"Erreur 
  rechargement: {e}")

  # ============= ENDPOINT DE HEALTH CHECK =============

  @app.get("/health")
  @app.get("/")
  async def health_check():
      """
      Health check simple
      """
      return {
          "status": "healthy",
          "service": "Coqui TTS + Quranic Voices",
          "quranic_available": quranic_service is not None
      }

  if __name__ == "__main__":
      import uvicorn

      print("ğŸš€ DÃ©marrage du serveur Coqui TTS avec voix coraniques")
      print("ğŸ“ Endpoints disponibles:")
      print("   - POST /api/tts (standard, compatible Flutter)")
      print("   - POST /api/tts/quranic (rÃ©citateurs coraniques)")
      print("   - GET /api/reciters (liste des rÃ©citateurs)")
      print("   - GET /api/status (Ã©tat du service)")

      uvicorn.run(
          app,
          host="0.0.0.0",
          port=8001,
          workers=1  # Un seul worker pour Ã©viter les conflits GPU/mÃ©moire
      )

  ---
  ğŸ“ RÃ¨gles de Tajweed Ã  Respecter

  1. RÃ¨gles Prioritaires

  1.1 Madd (Ø§Ù„Ù…Ø¯) - Prolongation

  ğŸ¯ RÃˆGLES DE BASE:
  - Madd Tabii (Ø·Ø¨ÙŠØ¹ÙŠ): 2 temps - Ø­Ø±ÙˆÙ Ø§Ù„Ù…Ø¯ (Ø§ Ùˆ ÙŠ)
  - Madd Wajib (ÙˆØ§Ø¬Ø¨): 4-6 temps - avant Ù‡Ù…Ø²Ø© Ø§Ù„Ù‚Ø·Ø¹
  - Madd Layyin (Ù„ÙŠÙ†): 2-4-6 temps selon l'arrÃªt
  - Madd Silah (ØµÙ„Ø©): Ù‡Ù€ Ø§Ù„Ø¶Ù…ÙŠØ± connectÃ©e

  ğŸ“ IMPLÃ‰MENTATION:
  - DÃ©tecter automatiquement les patterns Ø§, Ùˆ, ÙŠ
  - Ajuster la durÃ©e selon le contexte
  - VÃ©rifier la position dans le mot

  1.2 Qalqalah (Ø§Ù„Ù‚Ù„Ù‚Ù„Ø©) - Vibration

  ğŸ¯ LETTRES CONCERNÃ‰ES: Ù‚ Ø· Ø¨ Ø¬ Ø¯

  ğŸ“ RÃˆGLES:
  - Qalqalah Kubra (ÙƒØ¨Ø±Ù‰): En fin de mot avec arrÃªt
  - Qalqalah Sughra (ØµØºØ±Ù‰): En milieu de mot avec sukun
  - Force selon la position et le contexte

  ğŸ“ IMPLÃ‰MENTATION:
  - DÃ©tecter les lettres Ù‚ Ø· Ø¨ Ø¬ Ø¯
  - Analyser la position (dÃ©but, milieu, fin)
  - Appliquer la vibration appropriÃ©e

  1.3 Ghunna (Ø§Ù„ØºÙ†Ø©) - Nasalisation

  ğŸ¯ DURÃ‰E: 2 temps de base

  ğŸ“ RÃˆGLES:
  - Noon/Meem avec Shaddah: ØºÙ†Ø© ÙƒØ§Ù…Ù„Ø©
  - Idgham avec Ghunna: ÙŠ Ù† Ù… Ùˆ
  - Ikhfa: Nasalisation cachÃ©e

  ğŸ“ IMPLÃ‰MENTATION:
  - DÃ©tecter Ù† et Ù… avec diacritiques
  - Ajuster la nasalisation selon la rÃ¨gle
  - Maintenir la durÃ©e appropriÃ©e

  2. RÃ¨gles d'Assimilation

  2.1 Idgham (Ø§Ù„Ø¥Ø¯ØºØ§Ù…) - Fusion

  ğŸ¯ LETTRES: ÙŠ Ø± Ù… Ù„ Ù† Ùˆ

  ğŸ“ TYPES:
  - Avec Ghunna: ÙŠ Ù† Ù… Ùˆ
  - Sans Ghunna: Ù„ Ø±
  - Complet vs Partiel

  ğŸ“ IMPLÃ‰MENTATION:
  - DÃ©tecter les rencontres Noon Sakinah + lettres Idgham
  - Appliquer la fusion appropriÃ©e
  - PrÃ©server ou ajouter la Ghunna

  2.2 Ikhfa (Ø§Ù„Ø¥Ø®ÙØ§Ø¡) - Dissimulation

  ğŸ¯ 15 LETTRES: Øª Ø« Ø¬ Ø¯ Ø° Ø² Ø³ Ø´ Øµ Ø¶ Ø· Ø¸ Ù Ù‚ Ùƒ

  ğŸ“ RÃˆGLE:
  - Noon Sakinah + une des 15 lettres
  - Nasalisation cachÃ©e sans fusion complÃ¨te
  - DurÃ©e: 2 temps avec Ghunna

  ğŸ“ IMPLÃ‰MENTATION:
  - DÃ©tecter Noon + lettres Ikhfa
  - Appliquer nasalisation intermÃ©diaire
  - Ã‰viter la fusion complÃ¨te

  3. RÃ¨gles de Pauses (Waqf)

  3.1 Signes de Ponctuation Coranique

  ğŸ“ SYMBOLES ET RÃˆGLES:
  Û– (Must Stop) - ArrÃªt obligatoire
  Û— (Permissible) - ArrÃªt permis
  Û˜ (Prefer Continue) - PrÃ©fÃ©rer continuer
  Û™ (Small Pause) - Petite pause
  Ûš (Stop Preferred) - ArrÃªt prÃ©fÃ©rable

  ğŸ“ IMPLÃ‰MENTATION:
  - ReconnaÃ®tre les symboles Unicode
  - Appliquer les pauses appropriÃ©es
  - Respecter le sens du verset

  4. Validation Automatique

  4.1 Script de Validation Tajweed

  CrÃ©er /var/coqui/quranic_voices/scripts/tajweed_validator.py:
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  Validateur des rÃ¨gles de Tajweed pour la synthÃ¨se vocale
  """

  import re
  import unicodedata
  from typing import List, Dict, Tuple

  class TajweedValidator:
      def __init__(self):
          # DÃ©finition des lettres et rÃ¨gles
          self.madd_letters = ['Ø§', 'Ùˆ', 'ÙŠ']
          self.qalqalah_letters = ['Ù‚', 'Ø·', 'Ø¨', 'Ø¬', 'Ø¯']
          self.idgham_letters = ['ÙŠ', 'Ø±', 'Ù…', 'Ù„', 'Ù†', 'Ùˆ']
          self.ikhfa_letters = ['Øª', 'Ø«', 'Ø¬', 'Ø¯', 'Ø°', 'Ø²', 'Ø³', 'Ø´',
  'Øµ', 'Ø¶', 'Ø·', 'Ø¸', 'Ù', 'Ù‚', 'Ùƒ']

          # Symboles de Waqf
          self.waqf_symbols = {
              '\u06D6': 'Must Stop',
              '\u06D7': 'Permissible',
              '\u06D8': 'Prefer Continue',
              '\u06D9': 'Small Pause',
              '\u06DA': 'Stop Preferred'
          }

      def analyze_text(self, text: str) -> Dict:
          """
          Analyser un texte coranique pour les rÃ¨gles de Tajweed
          """
          # Nettoyer le texte
          cleaned_text = self.clean_arabic_text(text)

          analysis = {
              'original_text': text,
              'cleaned_text': cleaned_text,
              'madd_occurrences': self.find_madd_rules(cleaned_text),
              'qalqalah_occurrences':
  self.find_qalqalah_rules(cleaned_text),
              'ghunna_occurrences': self.find_ghunna_rules(cleaned_text),
              'idgham_occurrences': self.find_idgham_rules(cleaned_text),
              'ikhfa_occurrences': self.find_ikhfa_rules(cleaned_text),
              'waqf_marks': self.find_waqf_marks(text),
              'complexity_score': 0
          }

          # Calculer un score de complexitÃ© Tajweed
          analysis['complexity_score'] =
  self.calculate_complexity(analysis)

          return analysis

      def clean_arabic_text(self, text: str) -> str:
          """Nettoyer le texte arabe en gardant les diacritiques 
  importantes"""
          # Garder les caractÃ¨res arabes et diacritiques essentiels
          cleaned = re.sub(r'[^\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\s]',
   '', text)
          return cleaned.strip()

      def find_madd_rules(self, text: str) -> List[Dict]:
          """Identifier les occurrences de Madd"""
          madd_cases = []

          for i, char in enumerate(text):
              if char in self.madd_letters:
                  context = text[max(0, i-2):i+3]
                  madd_type = self.classify_madd_type(char, context, i,
  text)

                  madd_cases.append({
                      'position': i,
                      'letter': char,
                      'type': madd_type,
                      'context': context,
                      'recommended_duration':
  self.get_madd_duration(madd_type)
                  })

          return madd_cases

      def classify_madd_type(self, letter: str, context: str, position: 
  int, full_text: str) -> str:
          """Classifier le type de Madd"""
          # Logique simplifiÃ©e - Ã  amÃ©liorer avec une analyse plus poussÃ©e
          next_char = full_text[position + 1] if position + 1 <
  len(full_text) else ''

          if next_char == 'Ø¡':  # Hamza
              return 'Madd Wajib'
          elif position == len(full_text) - 1:  # Fin de mot
              return 'Madd Layyin'
          else:
              return 'Madd Tabii'

      def get_madd_duration(self, madd_type: str) -> int:
          """Obtenir la durÃ©e recommandÃ©e pour un type de Madd"""
          durations = {
              'Madd Tabii': 2,
              'Madd Wajib': 5,  # 4-6 temps, moyenne 5
              'Madd Layyin': 4,  # 2-4-6 selon contexte, moyenne 4
              'Madd Silah': 2
          }
          return durations.get(madd_type, 2)

      def find_qalqalah_rules(self, text: str) -> List[Dict]:
          """Identifier les lettres de Qalqalah"""
          qalqalah_cases = []

          for i, char in enumerate(text):
              if char in self.qalqalah_letters:
                  # Analyser si la lettre a un sukun ou est en fin de mot
                  next_char = text[i + 1] if i + 1 < len(text) else ''
                  is_end_of_word = next_char == ' ' or i == len(text) - 1

                  qalqalah_type = 'Kubra' if is_end_of_word else 'Sughra'

                  qalqalah_cases.append({
                      'position': i,
                      'letter': char,
                      'type': qalqalah_type,
                      'strength': 'Strong' if qalqalah_type == 'Kubra' else
   'Medium'
                  })

          return qalqalah_cases

      def find_ghunna_rules(self, text: str) -> List[Dict]:
          """Identifier les cas de Ghunna"""
          ghunna_cases = []

          for i, char in enumerate(text):
              if char in ['Ù†', 'Ù…']:
                  # VÃ©rifier les conditions pour Ghunna
                  next_char = text[i + 1] if i + 1 < len(text) else ''

                  if next_char == 'Ù‘':  # Shaddah
                      ghunna_cases.append({
                          'position': i,
                          'letter': char,
                          'type': 'Shaddah Ghunna',
                          'duration': 2
                      })

          return ghunna_cases

      def find_idgham_rules(self, text: str) -> List[Dict]:
          """Identifier les cas d'Idgham"""
          # ImplÃ©mentation simplifiÃ©e
          # Dans une version complÃ¨te, analyser les rencontres Noon Sakinah
   + lettres Idgham
          return []

      def find_ikhfa_rules(self, text: str) -> List[Dict]:
          """Identifier les cas d'Ikhfa"""
          # ImplÃ©mentation simplifiÃ©e
          # Dans une version complÃ¨te, analyser les rencontres Noon Sakinah
   + lettres Ikhfa
          return []

      def find_waqf_marks(self, text: str) -> List[Dict]:
          """Identifier les marques de Waqf"""
          waqf_marks = []

          for i, char in enumerate(text):
              if char in self.waqf_symbols:
                  waqf_marks.append({
                      'position': i,
                      'symbol': char,
                      'rule': self.waqf_symbols[char],
                      'unicode': f'U+{ord(char):04X}'
                  })

          return waqf_marks

      def calculate_complexity(self, analysis: Dict) -> float:
          """Calculer un score de complexitÃ© Tajweed"""
          score = 0

          # Compter les diffÃ©rents types de rÃ¨gles
          score += len(analysis['madd_occurrences']) * 1.0
          score += len(analysis['qalqalah_occurrences']) * 1.5
          score += len(analysis['ghunna_occurrences']) * 2.0
          score += len(analysis['idgham_occurrences']) * 2.5
          score += len(analysis['ikhfa_occurrences']) * 2.0
          score += len(analysis['waqf_marks']) * 1.0

          # Normaliser par rapport Ã  la longueur du texte
          text_length = len(analysis['cleaned_text'])
          normalized_score = score / max(text_length, 1) * 100

          return min(normalized_score, 100)  # Cap Ã  100

  def validate_recitation_text(text: str) -> Dict:
      """
      Fonction principale de validation pour un texte de rÃ©citation
      """
      validator = TajweedValidator()
      analysis = validator.analyze_text(text)

      # Ajouter des recommandations
      recommendations = []

      if analysis['complexity_score'] > 70:
          recommendations.append("Texte complexe - synthÃ¨se lente 
  recommandÃ©e")

      if len(analysis['madd_occurrences']) > 5:
          recommendations.append("Nombreux Madd - attention aux 
  prolongations")

      if len(analysis['qalqalah_occurrences']) > 3:
          recommendations.append("Qalqalah multiples - emphase sur les 
  vibrations")

      analysis['recommendations'] = recommendations
      analysis['suitable_for_synthesis'] = analysis['complexity_score'] <
  80

      return analysis

  if __name__ == "__main__":
      # Test avec Al-Fatiha
      test_texts = [
          "Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø§Ù„Ø±ÙÙ‘Ø­Ù’Ù…ÙÙ°Ù†Ù Ø§Ù„Ø±ÙÙ‘Ø­ÙÙŠÙ…Ù",
          "Ø§Ù„Ù’Ø­ÙÙ…Ù’Ø¯Ù Ù„ÙÙ„ÙÙ‘Ù‡Ù Ø±ÙØ¨ÙÙ‘ Ø§Ù„Ù’Ø¹ÙØ§Ù„ÙÙ…ÙÙŠÙ†Ù",
          "Ù‚ÙÙ„Ù’ Ù‡ÙÙˆÙ Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø£ÙØ­ÙØ¯ÙŒ"
      ]

      for text in test_texts:
          print(f"\nğŸ“ Analyse: {text}")
          print("=" * 50)

          result = validate_recitation_text(text)

          print(f"ğŸ¯ Score complexitÃ©: {result['complexity_score']:.1f}")
          print(f"ğŸ¤ AdaptÃ© synthÃ¨se: {'Oui' if 
  result['suitable_for_synthesis'] else 'Non'}")

          if result['madd_occurrences']:
              print(f"ğŸ“ Madd trouvÃ©s: {len(result['madd_occurrences'])}")

          if result['qalqalah_occurrences']:
              print(f"ğŸ”¸ Qalqalah trouvÃ©s: 
  {len(result['qalqalah_occurrences'])}")

          if result['recommendations']:
              print("ğŸ’¡ Recommandations:")
              for rec in result['recommendations']:
                  print(f"   - {rec}")

  ---
  ğŸ§ª Tests et Validation

  1. Corpus de Test Coranique

  1.1 Versets de Validation par ComplexitÃ©

  CrÃ©er /var/coqui/quranic_voices/tests/test_corpus.json:
  {
    "test_categories": {
      "simple": {
        "description": "Versets simples pour tests de base",
        "texts": [
          {
            "id": "basmalah",
            "arabic": "Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø§Ù„Ø±ÙÙ‘Ø­Ù’Ù…ÙÙ°Ù†Ù Ø§Ù„Ø±ÙÙ‘Ø­ÙÙŠÙ…Ù",
            "transliteration": "Bismillahi ar-Rahmani ar-Raheem",
            "source": "DÃ©but de chaque sourate",
            "tajweed_focus": ["Madd Tabii", "Lam Shamsiyyah"],
            "complexity": 2
          },
          {
            "id": "ikhlas_1",
            "arabic": "Ù‚ÙÙ„Ù’ Ù‡ÙÙˆÙ Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø£ÙØ­ÙØ¯ÙŒ",
            "transliteration": "Qul huwa Allahu ahad",
            "source": "Sourate Al-Ikhlas, Verset 1",
            "tajweed_focus": ["Qalqalah", "Sukun"],
            "complexity": 3
          }
        ]
      },
      "medium": {
        "description": "Versets avec rÃ¨gles de Tajweed modÃ©rÃ©es",
        "texts": [
          {
            "id": "fatiha_2",
            "arabic": "Ø§Ù„Ù’Ø­ÙÙ…Ù’Ø¯Ù Ù„ÙÙ„ÙÙ‘Ù‡Ù Ø±ÙØ¨ÙÙ‘ Ø§Ù„Ù’Ø¹ÙØ§Ù„ÙÙ…ÙÙŠÙ†Ù",
            "transliteration": "Alhamdu lillahi rabbi al-alameen",
            "source": "Al-Fatiha, Verset 2",
            "tajweed_focus": ["Madd Tabii", "Lam Shamsiyyah", "Noon 
  Sakinah"],
            "complexity": 5
          },
          {
            "id": "adiyat_1",
            "arabic": "ÙˆÙØ§Ù„Ù’Ø¹ÙØ§Ø¯ÙÙŠÙØ§ØªÙ Ø¶ÙØ¨Ù’Ø­Ù‹Ø§",
            "transliteration": "Wal-adiyati dabha",
            "source": "Sourate Al-Adiyat, Verset 1",
            "tajweed_focus": ["Waw Sakt", "Tanween", "Idgham"],
            "complexity": 6
          }
        ]
      },
      "complex": {
        "description": "Versets complexes avec multiples rÃ¨gles",
        "texts": [
          {
            "id": "baqarah_255",
            "arabic": "Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ù„ÙØ§ Ø¥ÙÙ„ÙÙ°Ù‡Ù Ø¥ÙÙ„ÙÙ‘Ø§ Ù‡ÙÙˆÙ Ø§Ù„Ù’Ø­ÙÙŠÙÙ‘ Ø§Ù„Ù’Ù‚ÙÙŠÙÙ‘ÙˆÙ…Ù",
            "transliteration": "Allahu la ilaha illa huwa al-hayyu 
  al-qayyum",
            "source": "Al-Baqarah, Verset 255 (dÃ©but)",
            "tajweed_focus": ["Madd Wajib", "Shaddah", "Qalqalah",
  "Ghunna"],
            "complexity": 8
          }
        ]
      }
    },
    "validation_criteria": {
      "pronunciation_accuracy": "Respect des lettres arabes et 
  diacritiques",
      "tajweed_rules": "Application correcte des rÃ¨gles identifiÃ©es",
      "rhythm_flow": "FluiditÃ© naturelle de la rÃ©citation",
      "voice_consistency": "CohÃ©rence avec le style du rÃ©citateur"
    },
    "expected_durations": {
      "basmalah": "4-6 secondes",
      "short_ayah": "3-8 secondes",
      "medium_ayah": "8-15 secondes",
      "long_ayah": "15-30 secondes"
    }
  }

  1.2 Script de Test AutomatisÃ©

  CrÃ©er /var/coqui/quranic_voices/scripts/run_tests.py:
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  Suite de tests automatisÃ©s pour le systÃ¨me de rÃ©citation coranique
  """

  import json
  import time
  import os
  import sys
  from pathlib import Path
  from typing import Dict, List
  import librosa
  import numpy as np

  # Ajouter le chemin des scripts
  sys.path.append('/var/coqui/quranic_voices/scripts')

  try:
      from quranic_xtts_service import QuranicXTTSService
      from tajweed_validator import validate_recitation_text
  except ImportError as e:
      print(f"âŒ Erreur import: {e}")
      sys.exit(1)

  class QuranicTTSTestSuite:
      def __init__(self):
          self.service = None
          self.test_results = []
          self.output_dir = Path("/var/coqui/quranic_voices/tests/outputs")
          self.output_dir.mkdir(parents=True, exist_ok=True)

          # Charger le corpus de test
          self.load_test_corpus()

      def load_test_corpus(self):
          """Charger le corpus de test"""
          corpus_path =
  Path("/var/coqui/quranic_voices/tests/test_corpus.json")

          if corpus_path.exists():
              with open(corpus_path, 'r', encoding='utf-8') as f:
                  self.test_corpus = json.load(f)
          else:
              print(f"âš ï¸  Corpus de test non trouvÃ©: {corpus_path}")
              self.test_corpus = {"test_categories": {}}

      def setup_service(self):
          """Initialiser le service de rÃ©citation"""
          try:
              print("ğŸ¯ Initialisation du service de test...")
              self.service = QuranicXTTSService(low_memory_mode=True)

              validation = self.service.validate_setup()
              if not validation["overall_ready"]:
                  print(f"âš ï¸  Service partiellement prÃªt: {validation}")

              return True

          except Exception as e:
              print(f"âŒ Erreur initialisation service: {e}")
              return False

      def test_single_reciter(self, reciter_id: str, test_texts: 
  List[Dict]) -> Dict:
          """Tester un rÃ©citateur avec une liste de textes"""

          if not self.service or reciter_id not in
  self.service.reciters_config:
              return {"error": f"RÃ©citateur {reciter_id} non disponible"}

          reciter_results = {
              "reciter_id": reciter_id,
              "reciter_name":
  self.service.reciters_config[reciter_id]["name"],
              "tests": [],
              "summary": {
                  "total": len(test_texts),
                  "successful": 0,
                  "failed": 0,
                  "avg_synthesis_time": 0,
                  "avg_audio_duration": 0
              }
          }

          print(f"\nğŸ¤ Test du rÃ©citateur: 
  {reciter_results['reciter_name']}")
          print("-" * 50)

          synthesis_times = []
          audio_durations = []

          for i, test_text in enumerate(test_texts, 1):
              print(f"ğŸ“ Test {i}/{len(test_texts)}: {test_text['id']}")

              # GÃ©nÃ©rer le fichier de sortie
              output_file = self.output_dir /
  f"{reciter_id}_{test_text['id']}.wav"

              # Analyser le texte pour Tajweed
              tajweed_analysis =
  validate_recitation_text(test_text['arabic'])

              test_result = {
                  "test_id": test_text['id'],
                  "text": test_text['arabic'],
                  "transliteration": test_text.get('transliteration', ''),
                  "complexity": test_text.get('complexity', 0),
                  "tajweed_analysis": tajweed_analysis,
                  "synthesis_successful": False,
                  "synthesis_time": 0,
                  "audio_duration": 0,
                  "audio_quality": {},
                  "output_file": str(output_file)
              }

              try:
                  # SynthÃ¨se
                  start_time = time.time()

                  result = self.service.synthesize_ayah(
                      text=test_text['arabic'],
                      reciter=reciter_id,
                      apply_tajweed=True,
                      output_path=str(output_file)
                  )

                  synthesis_time = time.time() - start_time
                  test_result["synthesis_time"] = synthesis_time
                  synthesis_times.append(synthesis_time)

                  if result and output_file.exists():
                      test_result["synthesis_successful"] = True
                      reciter_results["summary"]["successful"] += 1

                      # Analyser l'audio gÃ©nÃ©rÃ©
                      audio_analysis =
  self.analyze_audio_quality(str(output_file))
                      test_result["audio_quality"] = audio_analysis
                      test_result["audio_duration"] =
  audio_analysis.get("duration", 0)

                      if audio_analysis.get("duration", 0) > 0:

  audio_durations.append(audio_analysis["duration"])

                      print(f"  âœ… SuccÃ¨s ({synthesis_time:.1f}s)")

                  else:
                      print(f"  âŒ Ã‰chec de synthÃ¨se")
                      reciter_results["summary"]["failed"] += 1

              except Exception as e:
                  print(f"  âŒ Erreur: {e}")
                  test_result["error"] = str(e)
                  reciter_results["summary"]["failed"] += 1

              reciter_results["tests"].append(test_result)

          # Calculer les moyennes
          if synthesis_times:
              reciter_results["summary"]["avg_synthesis_time"] =
  np.mean(synthesis_times)
          if audio_durations:
              reciter_results["summary"]["avg_audio_duration"] =
  np.mean(audio_durations)

          return reciter_results

      def analyze_audio_quality(self, audio_path: str) -> Dict:
          """Analyser la qualitÃ© de l'audio gÃ©nÃ©rÃ©"""
          try:
              # Charger l'audio avec librosa
              y, sr = librosa.load(audio_path, sr=None)

              analysis = {
                  "file_exists": True,
                  "sample_rate": sr,
                  "duration": len(y) / sr,
                  "rms_energy": float(np.sqrt(np.mean(y**2))),
                  "zero_crossing_rate":
  float(np.mean(librosa.feature.zero_crossing_rate(y)[0])),
                  "spectral_centroid":
  float(np.mean(librosa.feature.spectral_centroid(y=y, sr=sr)[0])),
                  "file_size_bytes": os.path.getsize(audio_path)
              }

              # Validation de base
              analysis["quality_flags"] = []

              if analysis["duration"] < 1.0:
                  analysis["quality_flags"].append("DurÃ©e trÃ¨s courte")
              elif analysis["duration"] > 30.0:
                  analysis["quality_flags"].append("DurÃ©e trÃ¨s longue")

              if analysis["rms_energy"] < 0.01:
                  analysis["quality_flags"].append("Volume trÃ¨s faible")
              elif analysis["rms_energy"] > 0.8:
                  analysis["quality_flags"].append("Risque de saturation")

              analysis["overall_quality"] = "good" if
  len(analysis["quality_flags"]) == 0 else "issues"

              return analysis

          except Exception as e:
              return {
                  "file_exists": os.path.exists(audio_path),
                  "error": str(e),
                  "overall_quality": "error"
              }

      def run_comprehensive_tests(self) -> Dict:
          """ExÃ©cuter tous les tests de maniÃ¨re exhaustive"""
          print("ğŸ§ª DÃ‰BUT DES TESTS COMPLETS")
          print("=" * 60)

          if not self.setup_service():
              return {"error": "Impossible d'initialiser le service"}

          # Collecter tous les textes de test
          all_test_texts = []
          for category, data in self.test_corpus.get("test_categories",
  {}).items():
              all_test_texts.extend(data.get("texts", []))

          if not all_test_texts:
              return {"error": "Aucun texte de test trouvÃ©"}

          print(f"ğŸ“ {len(all_test_texts)} textes de test prÃ©parÃ©s")

          # Tester tous les rÃ©citateurs disponibles
          test_results = {
              "timestamp": time.time(),
              "test_summary": {
                  "total_reciters": 0,
                  "total_tests": 0,
                  "successful_tests": 0,
                  "failed_tests": 0
              },
              "reciters": {}
          }

          available_reciters = list(self.service.reciters_config.keys())
          test_results["test_summary"]["total_reciters"] =
  len(available_reciters)

          for reciter_id in available_reciters:
              print(f"\nğŸ¯ TEST RÃ‰CITATEUR: {reciter_id}")

              reciter_result = self.test_single_reciter(reciter_id,
  all_test_texts)
              test_results["reciters"][reciter_id] = reciter_result

              # Mise Ã  jour du rÃ©sumÃ© global
              if "summary" in reciter_result:
                  test_results["test_summary"]["total_tests"] +=
  reciter_result["summary"]["total"]
                  test_results["test_summary"]["successful_tests"] +=
  reciter_result["summary"]["successful"]
                  test_results["test_summary"]["failed_tests"] +=
  reciter_result["summary"]["failed"]

          # Sauvegarder les rÃ©sultats
          results_file = self.output_dir /
  f"test_results_{int(time.time())}.json"
          with open(results_file, 'w', encoding='utf-8') as f:
              json.dump(test_results, f, indent=2, ensure_ascii=False)

          print(f"\nğŸ“Š RÃ‰SUMÃ‰ DES TESTS")
          print("=" * 40)
          print(f"RÃ©citateurs testÃ©s: 
  {test_results['test_summary']['total_reciters']}")
          print(f"Tests totaux: 
  {test_results['test_summary']['total_tests']}")
          print(f"SuccÃ¨s: 
  {test_results['test_summary']['successful_tests']}")
          print(f"Ã‰checs: {test_results['test_summary']['failed_tests']}")

          if test_results['test_summary']['total_tests'] > 0:
              success_rate =
  (test_results['test_summary']['successful_tests'] /
                            test_results['test_summary']['total_tests']) *
  100
              print(f"Taux de succÃ¨s: {success_rate:.1f}%")

          print(f"ğŸ“„ RÃ©sultats dÃ©taillÃ©s: {results_file}")

          return test_results

      def run_quick_test(self) -> bool:
          """Test rapide avec la Basmalah sur tous les rÃ©citateurs"""
          print("âš¡ TEST RAPIDE - Basmalah")
          print("-" * 30)

          if not self.setup_service():
              return False

          test_text = "Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø§Ù„Ø±ÙÙ‘Ø­Ù’Ù…ÙÙ°Ù†Ù Ø§Ù„Ø±ÙÙ‘Ø­ÙÙŠÙ…Ù"
          all_passed = True

          for reciter_id in self.service.reciters_config.keys():
              try:
                  output_file = f"/tmp/quick_test_{reciter_id}.wav"

                  result = self.service.synthesize_ayah(
                      text=test_text,
                      reciter=reciter_id,
                      output_path=output_file
                  )

                  if result and os.path.exists(output_file):
                      file_size = os.path.getsize(output_file)
                      print(f"âœ… {reciter_id}: {file_size} bytes")

                      # Nettoyer
                      try:
                          os.remove(output_file)
                      except:
                          pass
                  else:
                      print(f"âŒ {reciter_id}: Ã‰chec")
                      all_passed = False

              except Exception as e:
                  print(f"âŒ {reciter_id}: {e}")
                  all_passed = False

          return all_passed

  if __name__ == "__main__":
      import argparse

      parser = argparse.ArgumentParser(description="Tests automatisÃ©s pour 
  TTS coranique")
      parser.add_argument("--quick", action="store_true", help="Test rapide
   seulement")
      parser.add_argument("--reciter", help="Tester un rÃ©citateur 
  spÃ©cifique")

      args = parser.parse_args()

      test_suite = QuranicTTSTestSuite()

      if args.quick:
          success = test_suite.run_quick_test()
          sys.exit(0 if success else 1)
      elif args.reciter:
          if not test_suite.setup_service():
              sys.exit(1)

          # Collecter les textes de test
          all_texts = []
          for category, data in
  test_suite.test_corpus.get("test_categories", {}).items():
              all_texts.extend(data.get("texts", []))

          if all_texts:
              result = test_suite.test_single_reciter(args.reciter,
  all_texts[:3])  # 3 premiers textes
              print(f"\nğŸ“Š RÃ©sultat pour {args.reciter}:")
              print(f"SuccÃ¨s: {result.get('summary', {}).get('successful', 
  0)}")
              print(f"Ã‰checs: {result.get('summary', {}).get('failed', 
  0)}")
          else:
              print("âŒ Aucun texte de test disponible")
              sys.exit(1)
      else:
          # Tests complets
          results = test_suite.run_comprehensive_tests()

          if "error" in results:
              print(f"âŒ Erreur: {results['error']}")
              sys.exit(1)

          # Exit code basÃ© sur le taux de succÃ¨s
          total = results['test_summary']['total_tests']
          successful = results['test_summary']['successful_tests']

          if total > 0 and (successful / total) >= 0.8:  # 80% de succÃ¨s 
  minimum
              sys.exit(0)
          else:
              sys.exit(1)

  ---
  ğŸš€ Maintenance et Surveillance

  1. Monitoring SystÃ¨me

  1.1 Script de Surveillance

  CrÃ©er /var/coqui/quranic_voices/scripts/monitor_service.py:
  #!/usr/bin/env python3
  """
  Surveillance continue du service TTS coranique
  """

  import time
  import json
  import psutil
  import requests
  from pathlib import Path
  import logging

  # Configuration du logging
  logging.basicConfig(
      level=logging.INFO,
      format='%(asctime)s - %(levelname)s - %(message)s',
      handlers=[
          logging.FileHandler('/var/log/quranic_tts_monitor.log'),
          logging.StreamHandler()
      ]
  )

  class QuranicTTSMonitor:
      def __init__(self):
          self.api_endpoint = "http://168.231.112.71:8001"
          self.check_interval = 300  # 5 minutes
          self.alert_threshold = {
              "cpu_percent": 80,
              "memory_percent": 85,
              "disk_percent": 90,
              "response_time": 10.0
          }

      def check_api_health(self):
          """VÃ©rifier l'Ã©tat de l'API"""
          try:
              start_time = time.time()
              response = requests.get(f"{self.api_endpoint}/api/status",
  timeout=10)
              response_time = time.time() - start_time

              if response.status_code == 200:
                  data = response.json()
                  return {
                      "status": "healthy",
                      "response_time": response_time,
                      "data": data
                  }
              else:
                  return {
                      "status": "error",
                      "http_code": response.status_code,
                      "response_time": response_time
                  }

          except Exception as e:
              return {
                  "status": "error",
                  "error": str(e),
                  "response_time": None
              }

      def check_system_resources(self):
          """VÃ©rifier les ressources systÃ¨me"""
          try:
              cpu_percent = psutil.cpu_percent(interval=1)
              memory = psutil.virtual_memory()
              disk = psutil.disk_usage('/')

              return {
                  "cpu_percent": cpu_percent,
                  "memory_percent": memory.percent,
                  "memory_available_gb": memory.available / 1024**3,
                  "disk_percent": disk.percent,
                  "disk_free_gb": disk.free / 1024**3
              }

          except Exception as e:
              logging.error(f"Erreur vÃ©rification ressources: {e}")
              return None

      def test_synthesis(self):
          """Tester la synthÃ¨se avec un texte simple"""
          try:
              test_payload = {
                  "text": "Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„ÙÙ‘Ù‡Ù Ø§Ù„Ø±ÙÙ‘Ø­Ù’Ù…ÙÙ°Ù†Ù Ø§Ù„Ø±ÙÙ‘Ø­ÙÙŠÙ…Ù",
                  "reciter": "mishary_rashid"
              }

              start_time = time.time()
              response = requests.post(
                  f"{self.api_endpoint}/api/tts/quranic",
                  json=test_payload,
                  timeout=30
              )
              synthesis_time = time.time() - start_time

              if response.status_code == 200:
                  data = response.json()
                  audio_size = len(data.get("audio", "")) if "audio" in
  data else 0

                  return {
                      "status": "success",
                      "synthesis_time": synthesis_time,
                      "audio_size": audio_size
                  }
              else:
                  return {
                      "status": "error",
                      "http_code": response.status_code,
                      "synthesis_time": synthesis_time
                  }

          except Exception as e:
              return {
                  "status": "error",
                  "error": str(e)
              }

      def run_monitoring_cycle(self):
          """ExÃ©cuter un cycle de surveillance complet"""
          logging.info("ğŸ” DÃ©but cycle de surveillance")

          # 1. VÃ©rifier l'API
          api_health = self.check_api_health()
          logging.info(f"API Status: {api_health['status']}")

          if api_health["response_time"] and api_health["response_time"] >
  self.alert_threshold["response_time"]:
              logging.warning(f"âš ï¸  API lente: 
  {api_health['response_time']:.1f}s")

          # 2. VÃ©rifier les ressources
          resources = self.check_system_resources()
          if resources:
              logging.info(f"Ressources - CPU: 
  {resources['cpu_percent']:.1f}%, "
                          f"RAM: {resources['memory_percent']:.1f}%, "
                          f"Disk: {resources['disk_percent']:.1f}%")

              # Alertes
              if resources["cpu_percent"] >
  self.alert_threshold["cpu_percent"]:
                  logging.warning(f"ğŸ”¥ CPU Ã©levÃ©: 
  {resources['cpu_percent']:.1f}%")

              if resources["memory_percent"] >
  self.alert_threshold["memory_percent"]:
                  logging.warning(f"ğŸ’¾ MÃ©moire Ã©levÃ©e: 
  {resources['memory_percent']:.1f}%")

              if resources["disk_percent"] >
  self.alert_threshold["disk_percent"]:
                  logging.warning(f"ğŸ’½ Disque plein: 
  {resources['disk_percent']:.1f}%")

          # 3. Tester la synthÃ¨se
          if api_health["status"] == "healthy":
              synthesis_test = self.test_synthesis()
              if synthesis_test["status"] == "success":
                  logging.info(f"âœ… Test synthÃ¨se OK 
  ({synthesis_test['synthesis_time']:.1f}s)")
              else:
                  logging.error(f"âŒ Test synthÃ¨se Ã©chouÃ©: 
  {synthesis_test}")

          # 4. Rapport complet
          report = {
              "timestamp": time.time(),
              "api_health": api_health,
              "system_resources": resources,
              "synthesis_test": synthesis_test if api_health["status"] ==
  "healthy" else None
          }

          # Sauvegarder le rapport
          report_file =
  f"/var/log/quranic_tts_report_{int(time.time())}.json"
          with open(report_file, 'w') as f:
              json.dump(report, f, indent=2)

          return report

      def run_continuous_monitoring(self):
          """Surveillance continue"""
          logging.info(f"ğŸ¯ DÃ©marrage surveillance continue (intervalle: 
  {self.check_interval}s)")

          while True:
              try:
                  self.run_monitoring_cycle()
                  time.sleep(self.check_interval)

              except KeyboardInterrupt:
                  logging.info("ğŸ›‘ ArrÃªt de la surveillance")
                  break
              except Exception as e:
                  logging.error(f"âŒ Erreur surveillance: {e}")
                  time.sleep(60)  # Pause d'1 minute en cas d'erreur

  if __name__ == "__main__":
      import argparse

      parser = argparse.ArgumentParser(description="Surveillance TTS 
  Coranique")
      parser.add_argument("--once", action="store_true", help="Un seul 
  cycle de vÃ©rification")
      parser.add_argument("--interval", type=int, default=300,
  help="Intervalle entre vÃ©rifications (secondes)")

      args = parser.parse_args()

      monitor = QuranicTTSMonitor()
      monitor.check_interval = args.interval

      if args.once:
          report = monitor.run_monitoring_cycle()
          print(json.dumps(report, indent=2))
      else:
          monitor.run_continuous_monitoring()

  2. Script de Maintenance

  CrÃ©er /var/coqui/quranic_voices/scripts/maintenance.sh:
  #!/bin/bash
  # Maintenance automatique du systÃ¨me TTS coranique

  LOG_FILE="/var/log/quranic_tts_maintenance.log"
  BACKUP_DIR="/var/backups/quranic_tts"
  MAX_CACHE_SIZE_MB=500

  log_message() {
      echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
  }

  # CrÃ©ation du rÃ©pertoire de backup
  mkdir -p "$BACKUP_DIR"

  log_message "ğŸ§¹ DÃ©but maintenance TTS Coranique"

  # 1. Nettoyer les fichiers temporaires
  log_message "ğŸ—‘ï¸  Nettoyage fichiers temporaires"
  find /tmp -name "quranic_*" -type f -mtime +1 -delete 2>/dev/null
  find /tmp -name "test_*.wav" -type f -mtime +1 -delete 2>/dev/null

  # 2. GÃ©rer le cache
  CACHE_DIR="/var/coqui/quranic_voices/cache"
  if [ -d "$CACHE_DIR" ]; then
      CACHE_SIZE=$(du -sm "$CACHE_DIR" | cut -f1)
      log_message "ğŸ“¦ Taille cache actuelle: ${CACHE_SIZE}MB"

      if [ "$CACHE_SIZE" -gt "$MAX_CACHE_SIZE_MB" ]; then
          log_message "âš ï¸  Cache trop volumineux, nettoyage..."
          find "$CACHE_DIR" -type f -mtime +7 -delete
          NEW_SIZE=$(du -sm "$CACHE_DIR" | cut -f1)
          log_message "âœ… Nouveau cache: ${NEW_SIZE}MB"
      fi
  fi

  # 3. Rotation des logs
  log_message "ğŸ“ Rotation des logs"
  if [ -f "/var/log/quranic_tts_monitor.log" ]; then
      if [ $(stat -f%z "/var/log/quranic_tts_monitor.log" 2>/dev/null ||
  stat -c%s "/var/log/quranic_tts_monitor.log") -gt 10485760 ]; then
          mv "/var/log/quranic_tts_monitor.log"
  "/var/log/quranic_tts_monitor.log.old"
          touch "/var/log/quranic_tts_monitor.log"
          log_message "âœ… Log rotatÃ©"
      fi
  fi

  # 4. VÃ©rifier l'espace disque
  DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
  log_message "ğŸ’½ Utilisation disque: ${DISK_USAGE}%"

  if [ "$DISK_USAGE" -gt 85 ]; then
      log_message "ğŸš¨ ALERTE: Espace disque critique!"
      # Nettoyer plus agressivement
      find /tmp -type f -mtime +0 -delete 2>/dev/null
  fi

  # 5. VÃ©rifier l'Ã©tat du service
  if systemctl is-active --quiet coqui-tts; then
      log_message "âœ… Service TTS actif"
  else
      log_message "âš ï¸  Service TTS inactif - tentative de redÃ©marrage"
      systemctl restart coqui-tts
      sleep 5
      if systemctl is-active --quiet coqui-tts; then
          log_message "âœ… Service redÃ©marrÃ© avec succÃ¨s"
      else
          log_message "âŒ Ã‰chec redÃ©marrage service"
      fi
  fi

  # 6. Backup des configurations importantes
  log_message "ğŸ’¾ Backup configurations"
  BACKUP_TODAY="$BACKUP_DIR/backup_$(date +%Y%m%d)"
  mkdir -p "$BACKUP_TODAY"

  # Sauvegarder les Ã©chantillons vocaux et mÃ©tadonnÃ©es
  if [ -d "/var/coqui/quranic_voices" ]; then
      tar -czf "$BACKUP_TODAY/quranic_voices_config.tar.gz" \
          --exclude="*.wav" --exclude="cache" --exclude="tests/outputs" \
          "/var/coqui/quranic_voices" 2>/dev/null
  fi

  # Nettoyer les vieux backups (>30 jours)
  find "$BACKUP_DIR" -type d -name "backup_*" -mtime +30 -exec rm -rf {} \;
   2>/dev/null

  log_message "âœ… Maintenance terminÃ©e"

  # 7. Test rapide du service
  log_message "ğŸ§ª Test rapide du service"
  python3 /var/coqui/quranic_voices/scripts/run_tests.py --quick >>
  "$LOG_FILE" 2>&1

  if [ $? -eq 0 ]; then
      log_message "âœ… Service fonctionnel"
  else
      log_message "âš ï¸  ProblÃ¨mes dÃ©tectÃ©s dans les tests"
  fi

  log_message "ğŸ Maintenance complÃ¨te"

  ---
  ğŸ“‹ Checklist Finale

  âœ… Actions Utilisateur Requises

  Phase 1 - PrÃ©paration Audio (CRITIQUE)
  - Obtenir Ã©chantillons audio de 15-25s pour chaque rÃ©citateur
  - VÃ©rifier les droits d'usage des enregistrements
  - Placer fichiers dans /audio_samples/source/
  - CrÃ©er test_corpus.json avec versets de validation

  Phase 2 - AccÃ¨s Serveur
  - Fournir accÃ¨s SSH au VPS (168.231.112.71)
  - Confirmer utilisateur avec droits sudo
  - VÃ©rifier espace disque disponible (>5GB)
  - Effectuer backup du systÃ¨me actuel

  ğŸ¤– Actions Assistant AutomatisÃ©es

  Installation et Configuration
  - Installation dÃ©pendances Python (TTS, torch, torchaudio)
  - CrÃ©ation structure rÃ©pertoires
  - DÃ©ploiement scripts de traitement
  - Configuration service XTTS coranique

  IntÃ©gration API
  - Extension API existante avec endpoints coraniques
  - Maintien compatibilitÃ© Flutter existante
  - Tests automatisÃ©s de tous les rÃ©citateurs
  - Configuration monitoring et maintenance

  ğŸ¯ CritÃ¨res de RÃ©ussite

  FonctionnalitÃ©
  - 4 rÃ©citateurs fonctionnels (Mishary, Sudais, Hudhaify, Afif)
  - SynthÃ¨se respectant les rÃ¨gles de Tajweed
  - Cache optimisÃ© pour performances
  - API compatible avec app Flutter existante

  Performance
  - SynthÃ¨se <10s pour versets courts
  - Cache hit instantanÃ©
  - MÃ©moire <4GB en utilisation normale
  - Taux de succÃ¨s >90% sur tests automatisÃ©s

  QualitÃ© Audio
  - Respect des caractÃ©ristiques vocales de chaque rÃ©citateur
  - Application correcte des rÃ¨gles de Madd, Qalqalah, Ghunna
  - FluiditÃ© naturelle de rÃ©citation
  - Absence de distorsions ou artefacts

  ---
  Temps estimÃ© total: 5-7 jours de travail
  Ressources VPS minimales: 4GB RAM, 4 CPU cores, 5GB stockage libre
  CompatibilitÃ©: Maintient 100% la compatibilitÃ© avec l'app Flutter
  existante

  Ce mÃ©moire constitue un guide complet pour implÃ©menter la rÃ©citation
  coranique authentique avec Tajweed dans votre systÃ¨me TTS Coqui existant.


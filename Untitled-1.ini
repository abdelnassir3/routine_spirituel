 Je suis maintenant dans le dossier /Users/mac/Documents/Projet_sprit.

> analyse de fond en comble pour comprendre comment est implementer TTS 
  Coqui/XTTS-v2 dans le projet

⏺ Update Todos
  ⎿  ☐ Analyser la structure du projet pour identifier les composants TTS
     ☐ Rechercher les fichiers liés à Coqui/XTTS-v2
     ☐ Analyser l'implémentation du TTS dans le code
     ☐ Examiner les dépendances et configuration TTS
     ☐ Documenter l'architecture TTS complète

⏺ List(.)
  ⎿  Listed 889 paths (ctrl+r to expand)

⏺ Search(pattern: "coqui|XTTS")
  ⎿  Found 38 files (ctrl+r to expand)

⏺ Update Todos
  ⎿  ☒ Analyser la structure du projet pour identifier les composants TTS
     ☒ Rechercher les fichiers liés à Coqui/XTTS-v2
     ☐ Analyser l'implémentation du TTS dans le code
     ☐ Examiner les dépendances et configuration TTS
     ☐ Documenter l'architecture TTS complète

⏺ Read(lib/core/services/coqui_tts_service.dart)
  ⎿  Read 512 lines (ctrl+r to expand)
  ⎿  CLAUDE.md

⏺ Read(lib/core/services/smart_tts_service.dart)
  ⎿  Read 571 lines (ctrl+r to expand)

⏺ Read(lib/core/services/tts_config_service.dart)
  ⎿  Read 146 lines (ctrl+r to expand)

⏺ Read(docs/COQUI_TTS_FINAL.md)
  ⎿  Read 143 lines (ctrl+r to expand)

⏺ Read(pubspec.yaml)
  ⎿  Read 92 lines (ctrl+r to expand)

⏺ Update Todos
  ⎿  ☒ Analyser la structure du projet pour identifier les composants TTS
     ☒ Rechercher les fichiers liés à Coqui/XTTS-v2
     ☒ Analyser l'implémentation du TTS dans le code
     ☒ Examiner les dépendances et configuration TTS
     ☐ Documenter l'architecture TTS complète

⏺ 📊 Analyse Complète : Implémentation TTS Coqui/XTTS-v2

  🏗️ Architecture Générale

  Structure TTS Multi-Provider

  SmartTtsService (Orchestrateur principal)
  ├── CoquiTtsService (XTTS-v2 sur VPS)
  │   ├── API REST: 168.231.112.71:8001
  │   ├── Cache sécurisé AES-256
  │   └── Retry avec exponential backoff
  └── FlutterTtsAudioService (Fallback système)
      └── Voix natives iOS/Android

  🔧 Services Principaux

  1. CoquiTtsService (lib/core/services/coqui_tts_service.dart)

  - Endpoint: http://168.231.112.71:8001/api/tts
  - Authentification: API Key stockée via FlutterSecureStorage
  - Format audio: MP3 encodé en Base64
  - Langues: Français, Arabe, Anglais, Espagnol
  - Timeouts dynamiques: 45s → 10min selon longueur texte

  Points Clés Techniques :

  // Timeout adaptatif pour textes longs
  final estimatedSeconds = (text.length / 20).ceil() + 40;
  final dynamicTimeout = Duration(seconds: estimatedSeconds.clamp(45,
  600));

  // Circuit breaker après 5 échecs consécutifs
  if (_consecutiveFailures >= _maxConsecutiveFailures) {
    throw Exception('Service TTS temporairement indisponible');
  }

  2. SmartTtsService (lib/core/services/smart_tts_service.dart)

  - Orchestrateur intelligent avec choix utilisateur
  - Queue de synthèse différée pour optimisation cache
  - Découpage automatique des textes >2000 caractères
  - Métriques de performance intégrées

  Logique de Décision :

  // Respecte le choix utilisateur (pas de fallback automatique)
  final bool useCoqui = _config.preferredProvider == 'coqui' &&
      _coquiService != null &&
      hasValidApiKey;

  3. TtsConfigService (lib/core/services/tts_config_service.dart)

  - Configuration sécurisée via FlutterSecureStorage
  - Endpoint par défaut: http://168.231.112.71:8001
  - Cache TTL: 7 jours configurable
  - Provider préféré: Choix utilisateur stocké

  🔐 Sécurité & Cache

  Cache Sécurisé (SecureTtsCacheService)

  - Chiffrement AES-256 des fichiers audio
  - Clé de cache : hash(provider + text + voice + speed + pitch)
  - TTL configuré : 7 jours par défaut
  - Limite stockage : 100MB

  Stockage Sécurisé

  // API Key protégée
  static const _keyCoquiApiKey = 'tts_coqui_api_key';
  await _storage.write(key: _keyCoquiApiKey, value: apiKey);

  // Masquage pour logs
  String get maskedApiKey => '${coquiApiKey.substring(0, 8)}...';

  🎛️ Interface Utilisateur

  Configuration dans Paramètres

  - Chemin : Paramètres > Voix et Lecture > Choix du moteur
  - Options :
    - Coqui TTS : Qualité naturelle (par défaut)
    - Voix système : Rapide mais robotique

  UX Optimisée

  - Indicateur de chargement première synthèse
  - Messages informatifs : "Première synthèse... Les suivantes seront
  instantanées !"
  - Pas de fallback automatique : Respect du choix utilisateur

  📡 Intégration API

  Payload Requête

  {
    "text": "النص المراد تحويله إلى صوت",
    "language": "ar",
    "voice_type": "female",
    "rate": "+0%"
  }

  Réponse

  {
    "audio": "UklGRlaDAABXQVZFZm10IBAAAAABAAEA..." // Base64
  }

  ⚡ Performance & Métriques

  Performances Observées

  | Métrique          | Valeur        |
  |-------------------|---------------|
  | Synthèse initiale | ~1-3 secondes |
  | Audio FR (moyen)  | ~26 KB        |
  | Audio AR (moyen)  | ~31 KB        |
  | Cache hit         | Instantané    |
  | Timeout max       | 10 minutes    |

  Optimisations

  - Découpage intelligent des textes longs
  - Queue background pour pré-cache
  - Retry exponential backoff : 100ms → 800ms
  - Circuit breaker après 5 échecs

  🔄 Fallback & Robustesse

  Stratégie Sans Fallback Automatique

  // PAS de fallback automatique - respecte le choix utilisateur
  throw Exception(
    'Coqui TTS non disponible. Veuillez réessayer ou changer de provider.'
  );

  Gestion d'Erreurs Robuste

  - Retry automatique sur erreurs réseau
  - Circuit breaker temporaire
  - Logs structurés pour debugging
  - Métriques de success rate

  📊 Intégration Riverpod

  Providers Architecture

  final smartTtsServiceProvider = Provider<AudioTtsService>((ref) {
    // Configuration async
    return configAsync.when(
      data: (config) => SmartTtsService(...),
      loading: () => ref.watch(flutterTtsServiceProvider),
      error: (error, stack) => ref.watch(flutterTtsServiceProvider),
    );
  });

  🎯 Points Forts Architecture

  ✅ Avantages Techniques

  1. Architecture modulaire : Services découplés et testables
  2. Sécurité first : API keys et cache chiffrés
  3. Performance intelligente : Cache, timeouts adaptatifs, queue
  4. UX transparente : Contrôle utilisateur total
  5. Robustesse : Circuit breaker, retry, logs complets

  🔍 Innovation Technique

  - Timeout dynamique basé sur longueur de texte
  - Découpage intelligent préservant le sens
  - Queue de synthèse différée pour optimisation
  - Choix utilisateur respecté sans confusion

⏺ Update Todos
  ⎿  ☒ Analyser la structure du projet pour identifier les composants TTS
     ☒ Rechercher les fichiers liés à Coqui/XTTS-v2
     ☒ Analyser l'implémentation du TTS dans le code
     ☒ Examiner les dépendances et configuration TTS
     ☒ Documenter l'architecture TTS complète

⏺ L'implémentation TTS Coqui/XTTS-v2 est très sophistiquée avec une
  architecture multi-provider intelligente, un cache sécurisé, et une UX
  optimisée donnant le contrôle total à l'utilisateur entre qualité (Coqui)
   et rapidité (système natif).

> voici ma question,comment je puisse entrainer TTS coqui que j'ai installe
   dans mon serveur VPS pour avoir différente voie, je voulais l'entrainer 
  pour la lecture de texte coranique avec des voies de lecture qui existe 
  comme miserai Rashid, Abdul Rahman As Sudais, Ali al Hudhaify, Afif 
  Mohammed Taj etc … ,j'aimerai que tu me reponde par oui ou non et si 
  c'est oui de me faire une implementation et pouvoir modifier les fichiers
   de serveur vps alors propose moi un plan, lis le fichier joint-ci pour 
  prendre quelque connaissance aussi 
  /Users/mac/Documents/Projet_sprit/conversation_tts_quranic.md

⏺ Read(conversation_tts_quranic.md)
  ⎿  Read 858 lines (ctrl+r to expand)

⏺ 📋 Réponse : Entraînement TTS Coqui pour Voix de Récitateurs Coraniques

  OUI

  C'est tout à fait possible d'entraîner votre serveur Coqui/XTTS-v2 avec
  des voix de récitateurs coraniques comme Mishary Rashid, Abdul Rahman
  As-Sudais, Ali al-Hudhaify, et Afif Mohammed Taj.

  🎯 Plan d'Implémentation

  Phase 1: Préparation des Échantillons Vocaux (2-3 jours)

  1.1 Collecte d'Échantillons Audio

  # Structure sur votre VPS
  mkdir -p
  /var/coqui/quranic_voices/{mishary_rashid,sudais,hudhaify,afif_taj}
  mkdir -p /var/coqui/quranic_voices/source_audio
  mkdir -p /var/coqui/quranic_voices/processed

  1.2 Script de Préparation Audio

  # prepare_quranic_voices.py
  import torchaudio
  import torch
  from pydub import AudioSegment
  import os

  class QuranicVoicePreparer:
      def __init__(self):
          self.target_sr = 22050
          self.reciters = {
              "mishary_rashid": "Mishary Rashid Alafasy",
              "sudais": "Abdul Rahman As-Sudais",
              "hudhaify": "Ali Al-Hudhaify",
              "afif_taj": "Afif Mohammed Taj"
          }

      def extract_clean_sample(self, source_audio, reciter_name, 
  start_sec=10, duration=15):
          """Extraire 15 secondes de récitation claire"""
          audio = AudioSegment.from_file(source_audio)

          # Mono + 22050Hz
          audio = audio.set_channels(1).set_frame_rate(self.target_sr)

          # Segment entre 10-25 secondes (éviter début/fin)
          start_ms = start_sec * 1000
          segment = audio[start_ms:start_ms + (duration * 1000)]

          # Normaliser et réduire bruit
          segment = segment.normalize()

          # Sauvegarder
          output_path =
  f"/var/coqui/quranic_voices/{reciter_name}/sample.wav"
          segment.export(output_path, format="wav")

          return output_path

  # Utilisation
  preparer = QuranicVoicePreparer()

  Phase 2: Configuration XTTS-v2 (1 jour)

  2.1 Mise à Jour du Service Coqui

  # quranic_xtts_service.py
  from TTS.api import TTS
  import torch
  import json
  import os

  class QuranicXTTSService:
      def __init__(self):
          self.device = "cuda" if torch.cuda.is_available() else "cpu"
          self.tts =
  TTS("tts_models/multilingual/multi-dataset/xtts_v2").to(self.device)

          # Configuration des récitateurs
          self.reciters = {
              "mishary_rashid": {
                  "name": "Mishary Rashid Alafasy",
                  "sample":
  "/var/coqui/quranic_voices/mishary_rashid/sample.wav",
                  "speed": 0.85,
                  "temperature": 0.5
              },
              "sudais": {
                  "name": "Abdul Rahman As-Sudais",
                  "sample": "/var/coqui/quranic_voices/sudais/sample.wav",
                  "speed": 0.8,
                  "temperature": 0.45
              },
              "hudhaify": {
                  "name": "Ali Al-Hudhaify",
                  "sample":
  "/var/coqui/quranic_voices/hudhaify/sample.wav",
                  "speed": 0.9,
                  "temperature": 0.5
              },
              "afif_taj": {
                  "name": "Afif Mohammed Taj",
                  "sample":
  "/var/coqui/quranic_voices/afif_taj/sample.wav",
                  "speed": 0.88,
                  "temperature": 0.55
              }
          }

      def synthesize_quranic(self, text, reciter="mishary_rashid"):
          """Synthétiser avec voix de récitateur"""
          if reciter not in self.reciters:
              raise ValueError(f"Récitateur {reciter} non disponible")

          config = self.reciters[reciter]

          return self.tts.tts(
              text=text,
              speaker_wav=config["sample"],
              language="ar",
              speed=config["speed"],
              temperature=config["temperature"],
              top_p=0.85,
              top_k=50
          )

  Phase 3: Modification de l'API Existante (1 jour)

  3.1 Extension de l'API VPS

  # Ajouter à votre API existante sur 168.231.112.71:8001
  from quranic_xtts_service import QuranicXTTSService

  app = FastAPI()
  quranic_tts = QuranicXTTSService()

  @app.post("/api/tts/quranic")
  async def synthesize_quranic(request: dict):
      """Nouveau endpoint pour récitation coranique"""

      text = request.get("text", "")
      reciter = request.get("reciter", "mishary_rashid")
      voice_type = request.get("voice_type", "male")  # Ignoré pour 
  récitateurs

      try:
          # Utiliser le service de récitation coranique
          audio_data = quranic_tts.synthesize_quranic(text, reciter)

          # Encoder en base64 comme votre API actuelle
          import base64
          audio_b64 = base64.b64encode(audio_data).decode()

          return {"audio": audio_b64, "reciter": reciter}

      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))

  @app.get("/api/reciters")
  async def list_reciters():
      """Lister les récitateurs disponibles"""
      return {
          "reciters": list(quranic_tts.reciters.keys()),
          "details": quranic_tts.reciters
      }

  Phase 4: Intégration Flutter (1 jour)

  4.1 Modification du CoquiTtsService

  // Ajouter à lib/core/services/coqui_tts_service.dart

  class CoquiTtsService {
    // ... code existant ...

    /// Liste des récitateurs coraniques disponibles
    static const quranicReciters = {
      'mishary_rashid': 'Mishary Rashid Alafasy',
      'sudais': 'Abdul Rahman As-Sudais',
      'hudhaify': 'Ali Al-Hudhaify',
      'afif_taj': 'Afif Mohammed Taj',
    };

    Future<String?> _synthesizeQuranicWithCoqui({
      required String text,
      required String reciter,
      required double speed,
      required String cacheKey,
    }) async {

      // Utiliser l'endpoint dédié aux récitateurs
      final response = await _dio.post(
        '${_config.coquiEndpoint}/api/tts/quranic',
        data: {
          'text': text,
          'reciter': reciter,
          'rate': _speedToRate(speed),
        },
        options: Options(headers: {'X-API-Key': _config.coquiApiKey}),
      );

      if (response.statusCode == 200) {
        final audioBase64 = response.data['audio'] as String?;
        if (audioBase64?.isNotEmpty == true) {
          final audioBytes = base64Decode(audioBase64);
          final tempDir = await getTemporaryDirectory();
          final tempFile = File('${tempDir.path}/$cacheKey.mp3');
          await tempFile.writeAsBytes(audioBytes);
          return tempFile.path;
        }
      }
      return null;
    }

    /// Jouer avec voix de récitateur coranique
    Future<void> playQuranicText(
      String text, {
      required String reciter,
      double speed = 0.85,
    }) async {

      if (!quranicReciters.containsKey(reciter)) {
        throw Exception('Récitateur $reciter non disponible');
      }

      // Générer clé de cache avec récitateur
      final cacheKey = await _cache.generateKey(
        provider: 'coqui_quranic',
        text: text,
        voice: reciter,
        speed: speed,
        pitch: 1.0,
      );

      // Vérifier cache
      String? audioPath = await _cache.getPath(cacheKey);

      if (audioPath == null || !File(audioPath).existsSync()) {
        audioPath = await _synthesizeQuranicWithCoqui(
          text: text,
          reciter: reciter,
          speed: speed,
          cacheKey: cacheKey,
        );

        if (audioPath != null) {
          await _cache.store(
            key: cacheKey,
            filePath: audioPath,
            metadata: {
              'provider': 'coqui_quranic',
              'reciter': reciter,
              'timestamp': DateTime.now().toIso8601String(),
            },
          );
        }
      }

      if (audioPath != null) {
        await _audioPlayer.setFilePath(audioPath);
        await _audioPlayer.play();
      }
    }
  }

  4.2 Interface Utilisateur - Sélecteur de Récitateur

  // lib/features/settings/quranic_voice_selector.dart
  class QuranicVoiceSelector extends ConsumerWidget {
    @override
    Widget build(BuildContext context, WidgetRef ref) {
      return Column(
        children: [
          Text('Voix de Récitation Coranique'),
          ...CoquiTtsService.quranicReciters.entries.map((entry) {
            return ListTile(
              title: Text(entry.value),
              subtitle: Text('Récitateur: ${entry.key}'),
              onTap: () => _testReciter(entry.key),
            );
          }),
        ],
      );
    }

    Future<void> _testReciter(String reciter) async {
      final tts = ref.read(coquiTtsServiceProvider);
      await tts.playQuranicText(
        'بِسْمِ اللَّهِ الرَّحْمَٰنِ الرَّحِيمِ',
        reciter: reciter,
      );
    }
  }

  Phase 5: Déploiement (1 jour)

  5.1 Script de Déploiement VPS

  #!/bin/bash
  # deploy_quranic_voices.sh

  # Arrêter le service existant
  sudo systemctl stop coqui-tts

  # Backup de la configuration actuelle
  cp -r /var/coqui /var/coqui_backup_$(date +%Y%m%d)

  # Créer structure pour voix coraniques
  mkdir -p
  /var/coqui/quranic_voices/{mishary_rashid,sudais,hudhaify,afif_taj}

  # Copier les nouveaux fichiers
  cp quranic_xtts_service.py /var/coqui/
  cp prepare_quranic_voices.py /var/coqui/

  # Mettre à jour l'API
  cp api_with_quranic.py /var/coqui/main.py

  # Redémarrer le service
  sudo systemctl start coqui-tts
  sudo systemctl status coqui-tts

  📊 Ressources Nécessaires

  Serveur VPS

  - RAM: 4GB minimum (8GB recommandé)
  - CPU: 4 cores minimum
  - Stockage: +2GB pour échantillons et cache
  - GPU: Optionnel (10x plus rapide)

  Échantillons Audio

  - Durée: 10-20 secondes par récitateur
  - Qualité: Audio clair, sans bruit de fond
  - Format: WAV 22050Hz mono

  ✅ Avantages de cette Approche

  1. Intégration transparente avec votre système existant
  2. Choix utilisateur entre récitateurs célèbres
  3. Cache intelligent pour performances optimales
  4. API RESTful maintenant la compatibilité
  5. Déploiement incrémental sans casser l'existant

  🚀 Résultat Final

  Votre app aura:
  - 4 voix de récitateurs célèbres pour la lecture coranique
  - Sélection intuitive dans les paramètres
  - Performances identiques à votre système actuel
  - Cache optimisé pour lectures répétées

  Temps estimé total: 5-7 jours pour implémentation complète avec tests.

> genere moi un document memoire markdown  pour cette implementation, tout 
  ce que je dois a preter et les actions que je dois faire sans passer par 
  toi sur le serveur vps et les actions que tu pourras les faires 
  directement via IP du serveur etc fichier audio et texte a preparer, je 
  veux que la lecture soit dans la regle du coran, taswid

⏺ 📚 Mémoire d'Implémentation - TTS Coqui pour Récitation Coranique avec 
  Tajweed

  📋 Table des Matières

  1. #vue-densemble
  2. #prérequis-et-préparation
  3. #actions-utilisateur-sans-assistant
  4. #actions-assistant-via-ip-serveur
  5. #règles-de-tajweed-à-respecter
  6. #tests-et-validation
  7. #maintenance-et-surveillance

  ---
  🎯 Vue d'ensemble

  Objectif

  Intégrer 4 voix de récitateurs coraniques célèbres dans votre système TTS
   Coqui existant, en respectant les règles de Tajweed pour une récitation
  authentique.

  Récitateurs Cibles

  - Mishary Rashid Alafasy (الشيخ مشاري راشد العفاسي)
  - Abdul Rahman As-Sudais (الشيخ عبد الرحمن السديس)
  - Ali Al-Hudhaify (الشيخ علي الحذيفي)
  - Afif Mohammed Taj (الشيخ عفيف محمد تاج)

  Architecture Finale

  App Flutter → SmartTtsService → CoquiTtsService → VPS API
  (168.231.112.71:8001)
                                                        ↓
                                                 QuranicXTTSService
                                                        ↓
                                              4 Voix de Récitateurs

  ---
  🛠️ Prérequis et Préparation

  Serveur VPS - Spécifications Minimales

  - RAM: 6GB (8GB recommandé pour 4 voix simultanées)
  - CPU: 4 cores minimum (Intel/AMD x64)
  - Stockage: +5GB libres pour échantillons et cache
  - OS: Ubuntu 20.04+ ou CentOS 8+
  - Python: 3.8+ avec pip
  - GPU: Optionnel (NVIDIA avec CUDA pour 10x performances)

  Logiciels à Installer sur VPS

  # Outils audio essentiels
  sudo apt update
  sudo apt install ffmpeg sox libsox-fmt-all python3-pip python3-venv

  # Vérifier Python version
  python3 --version  # Doit être ≥ 3.8

  Droits d'Usage - ⚠️ IMPORTANT

  - Vérifier les droits d'utilisation des enregistrements des récitateurs
  - Contacter les détenteurs de droits si nécessaire
  - Usage éducatif/religieux généralement autorisé mais à confirmer
  - Respecter les licences Creative Commons si disponibles

  ---
  👤 Actions Utilisateur (Sans Assistant)

  1. Collecte des Échantillons Audio (CRITIQUE)

  1.1 Sources Recommandées

  - Haramain Recordings (site officiel des Deux Saintes Mosquées)
  - Masjid Al-Haram (enregistrements officiels)
  - Islamic Audio Library (avec permissions)
  - YouTube (vérifier droits d'usage)

  1.2 Critères de Sélection Audio

  ✅ OBLIGATOIRE pour chaque récitateur:
  - Durée: 15-25 secondes de récitation continue
  - Qualité: Enregistrement studio ou mosquée (sans écho)
  - Contenu: Versets avec Tajweed clair et correct
  - Format: MP3/WAV haute qualité (≥128kbps)
  - Langue: Arabe classique (Fusha)
  - Silence: Pas de fond musical ou bruit parasite

  🎯 IDÉAL:
  - Récitation de sourates courtes (Al-Fatiha, Al-Ikhlas, Al-Falaq)
  - Tempo modéré (ni trop rapide, ni trop lent)
  - Voix claire sans fatigue
  - Respect du Waqf (pauses appropriées)

  1.3 Structure des Fichiers à Préparer

  audio_samples/
  ├── source/
  │   ├── mishary_rashid_original.mp3
  │   ├── sudais_original.mp3
  │   ├── hudhaify_original.mp3
  │   └── afif_taj_original.mp3
  └── metadata.txt  # Notes sur sources et droits

  2. Préparation du Corpus de Test

  2.1 Textes de Validation (Format UTF-8)

  Créer test_corpus.json:
  {
    "validation_texts": [
      {
        "id": "fatiha_1",
        "arabic": "بِسْمِ اللَّهِ الرَّحْمَٰنِ الرَّحِيمِ",
        "transliteration": "Bismillahi ar-Rahmani ar-Raheem",
        "tajweed_rules": ["Basmalah", "Madd_Tabii", "Qalqalah"]
      },
      {
        "id": "fatiha_2",
        "arabic": "الْحَمْدُ لِلَّهِ رَبِّ الْعَالَمِينَ",
        "transliteration": "Alhamdu lillahi rabbi al-alameen",
        "tajweed_rules": ["Madd_Tabii", "Lam_Shamsiyyah"]
      },
      {
        "id": "ikhlas_1",
        "arabic": "قُلْ هُوَ اللَّهُ أَحَدٌ",
        "transliteration": "Qul huwa Allahu ahad",
        "tajweed_rules": ["Qalqalah", "Sukun", "Tanween"]
      },
      {
        "id": "complex_ayah",
        "arabic": "وَالْعَادِيَاتِ ضَبْحًا",
        "transliteration": "Wal-adiyati dabha",
        "tajweed_rules": ["Waw_Sakt", "Idgham", "Tanween"]
      }
    ]
  }

  2.2 Règles de Tajweed à Documenter

  Créer tajweed_reference.md:
  # Règles de Tajweed pour Validation

  ## Règles Prioritaires à Respecter:

  ### 1. Madd (المد) - Prolongation
  - **Madd Tabii**: 2 temps (حروف المد)
  - **Madd Wajib**: 4-6 temps (avant همزة)
  - **Madd Layyin**: 2-4-6 temps selon contexte

  ### 2. Qalqalah (القلقلة) - Vibration
  - Lettres: ق ط ب ج د
  - Forte en fin de mot
  - Faible en milieu de mot

  ### 3. Ghunna (الغنة) - Nasalisation
  - Durée: 2 temps
  - Lettres: م ن dans certains cas

  ### 4. Idgham (الإدغام) - Fusion
  - Avec Ghunna: ي ن م و
  - Sans Ghunna: ل ر

  ### 5. Waqf (الوقف) - Pauses
  - Respecter les signes de ponctuation coranique
  - Pauses appropriées selon le sens

  3. Accès Serveur VPS

  3.1 Informations de Connexion à Fournir

  # IP du serveur
  IP_SERVER="168.231.112.71"

  # Port SSH (si différent de 22)
  SSH_PORT="22"

  # Utilisateur avec droits sudo
  USERNAME="votre_user"

  # Mot de passe ou clé SSH
  # (Ne PAS documenter ici - transmettre séparément)

  # Répertoire de travail Coqui existant
  COQUI_DIR="/var/coqui"  # À confirmer

  3.2 Test de Connectivité

  # Tester la connexion SSH
  ssh -p 22 username@168.231.112.71 "echo 'Connexion OK'"

  # Vérifier l'état du service Coqui actuel
  ssh username@168.231.112.71 "sudo systemctl status coqui-tts"

  # Vérifier l'espace disque
  ssh username@168.231.112.71 "df -h"

  4. Backup Prérequis

  4.1 Sauvegarde du Système Actuel

  # Créer un backup complet avant modifications
  ssh username@168.231.112.71 "
  sudo systemctl stop coqui-tts
  sudo cp -r /var/coqui /var/coqui_backup_$(date +%Y%m%d_%H%M)
  sudo systemctl start coqui-tts
  "

  4.2 Point de Restauration

  Documenter la procédure de rollback:
  # En cas de problème, restaurer avec:
  sudo systemctl stop coqui-tts
  sudo rm -rf /var/coqui
  sudo mv /var/coqui_backup_YYYYMMDD_HHMM /var/coqui
  sudo systemctl start coqui-tts

  ---
  🤖 Actions Assistant (Via IP Serveur)

  1. Préparation de l'Environnement

  1.1 Installation des Dépendances Python

  # Mise à jour du système
  sudo apt update && sudo apt upgrade -y

  # Installation des bibliothèques audio
  sudo apt install -y ffmpeg sox libsox-fmt-all portaudio19-dev

  # Mise à jour de TTS vers la dernière version
  pip3 install --upgrade TTS torch torchaudio

  # Installation des dépendances pour le traitement audio
  pip3 install pydub librosa soundfile

  1.2 Structure des Répertoires

  # Créer l'arborescence pour les voix coraniques
  sudo mkdir -p
  /var/coqui/quranic_voices/{mishary_rashid,sudais,hudhaify,afif_taj}
  sudo mkdir -p /var/coqui/quranic_voices/{source,processed,cache}
  sudo mkdir -p /var/coqui/quranic_voices/scripts
  sudo mkdir -p /var/coqui/quranic_voices/tests

  # Permissions appropriées
  sudo chown -R coqui:coqui /var/coqui/quranic_voices
  sudo chmod -R 755 /var/coqui/quranic_voices

  2. Scripts de Traitement Audio

  2.1 Préparateur d'Échantillons Vocaux

  Créer /var/coqui/quranic_voices/scripts/prepare_voices.py:
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  Préparateur d'échantillons vocaux pour récitateurs coraniques
  Respecte les spécifications XTTS-v2 et les règles de Tajweed
  """

  import os
  import torch
  import torchaudio
  from pydub import AudioSegment
  import numpy as np
  import argparse
  import json
  from pathlib import Path

  class QuranicVoicePreparer:
      def __init__(self, base_dir="/var/coqui/quranic_voices"):
          self.base_dir = Path(base_dir)
          self.target_sr = 22050  # Fréquence optimale pour XTTS-v2
          self.target_duration = 15  # Durée cible en secondes

          # Configuration des récitateurs avec leurs caractéristiques
          self.reciters_config = {
              "mishary_rashid": {
                  "name": "Mishary Rashid Alafasy",
                  "name_arabic": "مشاري راشد العفاسي",
                  "speed_factor": 0.85,
                  "pitch_optimal": "medium-low",
                  "tajweed_style": "classical"
              },
              "sudais": {
                  "name": "Abdul Rahman As-Sudais",
                  "name_arabic": "عبد الرحمن السديس",
                  "speed_factor": 0.80,
                  "pitch_optimal": "medium",
                  "tajweed_style": "madinah"
              },
              "hudhaify": {
                  "name": "Ali Al-Hudhaify",
                  "name_arabic": "علي الحذيفي",
                  "speed_factor": 0.90,
                  "pitch_optimal": "medium-high",
                  "tajweed_style": "classical"
              },
              "afif_taj": {
                  "name": "Afif Mohammed Taj",
                  "name_arabic": "عفيف محمد تاج",
                  "speed_factor": 0.88,
                  "pitch_optimal": "medium",
                  "tajweed_style": "modern"
              }
          }

      def analyze_audio_quality(self, audio_path):
          """
          Analyser la qualité audio pour validation Tajweed
          """
          try:
              audio = AudioSegment.from_file(audio_path)

              # Métriques de base
              metrics = {
                  "duration_seconds": len(audio) / 1000.0,
                  "sample_rate": audio.frame_rate,
                  "channels": audio.channels,
                  "bit_depth": audio.sample_width * 8,
                  "average_dBFS": audio.dBFS,
                  "max_dBFS": audio.max_dBFS,
                  "rms_dBFS": audio.rms
              }

              # Validation pour récitation coranique
              quality_issues = []

              if metrics["duration_seconds"] < 10:
                  quality_issues.append("Durée trop courte (< 10s)")
              if metrics["duration_seconds"] > 30:
                  quality_issues.append("Durée trop longue (> 30s)")
              if metrics["sample_rate"] < 16000:
                  quality_issues.append("Fréquence d'échantillonnage trop 
  basse")
              if metrics["average_dBFS"] < -30:
                  quality_issues.append("Volume trop faible")
              if metrics["max_dBFS"] > -3:
                  quality_issues.append("Risque de saturation")

              metrics["quality_issues"] = quality_issues
              metrics["suitable_for_xtts"] = len(quality_issues) == 0

              return metrics

          except Exception as e:
              return {"error": str(e)}

      def extract_optimal_segment(self, source_path, reciter_id, 
  start_offset=5):
          """
          Extraire le segment optimal pour XTTS-v2
          Prend en compte les règles de Tajweed
          """

          if reciter_id not in self.reciters_config:
              raise ValueError(f"Récitateur {reciter_id} non reconnu")

          config = self.reciters_config[reciter_id]

          # Charger et analyser l'audio source
          audio = AudioSegment.from_file(source_path)
          total_duration = len(audio) / 1000.0

          print(f"🎤 Traitement: {config['name']} 
  ({config['name_arabic']})")
          print(f"📊 Audio source: {total_duration:.1f}s, 
  {audio.frame_rate}Hz, {audio.channels}ch")

          # Déterminer le meilleur segment
          if total_duration < self.target_duration:
              print("⚠️  Audio source plus court que la durée cible")
              segment = audio
              actual_start = 0
          else:
              # Éviter le début (souvent silence ou Ta'awwudh)
              # et la fin (possible coupure)
              safe_start = max(start_offset, total_duration * 0.1)
              safe_end = total_duration * 0.9
              available_duration = safe_end - safe_start

              if available_duration >= self.target_duration:
                  # Choisir un segment au milieu pour avoir du Tajweed 
  fluide
                  segment_start = safe_start + (available_duration -
  self.target_duration) / 2
                  actual_start = segment_start
              else:
                  segment_start = safe_start
                  actual_start = segment_start

              start_ms = int(segment_start * 1000)
              end_ms = min(start_ms + (self.target_duration * 1000),
  len(audio))
              segment = audio[start_ms:end_ms]

          # Optimisations pour XTTS-v2
          # 1. Convertir en mono
          if segment.channels > 1:
              segment = segment.set_channels(1)
              print("🔄 Conversion en mono")

          # 2. Ajuster la fréquence d'échantillonnage
          if segment.frame_rate != self.target_sr:
              segment = segment.set_frame_rate(self.target_sr)
              print(f"🔄 Resampling vers {self.target_sr}Hz")

          # 3. Normalisation douce (préserver la dynamique du Tajweed)
          target_dBFS = -20.0  # Volume optimal pour la parole
          gain_needed = target_dBFS - segment.dBFS
          if abs(gain_needed) > 1.0:  # Ajuster seulement si nécessaire
              segment = segment + gain_needed
              print(f"🔄 Normalisation: {gain_needed:+.1f}dB")

          # 4. Réduction légère du bruit (préserver la qualité vocale)
          # Appliquer un filtre passe-haut léger pour réduire les basses 
  fréquences
          segment = segment.high_pass_filter(80)

          # 5. Fade in/out pour éviter les clics
          segment = segment.fade_in(50).fade_out(50)

          # Sauvegarder le segment traité
          output_dir = self.base_dir / reciter_id
          output_dir.mkdir(exist_ok=True)

          output_path = output_dir / "sample.wav"
          segment.export(str(output_path), format="wav")

          # Métadonnées de traitement
          metadata = {
              "reciter": config,
              "source_file": str(source_path),
              "segment_start_seconds": actual_start,
              "segment_duration_seconds": len(segment) / 1000.0,
              "processing_date": str(datetime.now()),
              "xtts_optimized": True,
              "quality_metrics":
  self.analyze_audio_quality(str(output_path))
          }

          # Sauvegarder les métadonnées
          metadata_path = output_dir / "metadata.json"
          with open(metadata_path, 'w', encoding='utf-8') as f:
              json.dump(metadata, f, indent=2, ensure_ascii=False)

          print(f"✅ Échantillon créé: {output_path}")
          print(f"📝 Métadonnées: {metadata_path}")
          print(f"⏱️  Durée finale: {len(segment)/1000:.1f}s")

          return str(output_path), metadata

      def validate_tajweed_compatibility(self, audio_path):
          """
          Validation spécifique pour la récitation coranique
          """
          try:
              waveform, sample_rate = torchaudio.load(audio_path)

              # Analyse spectrale pour détecter les caractéristiques du 
  Tajweed
              spectrogram = torchaudio.transforms.Spectrogram()(waveform)

              validation_results = {
                  "spectral_clarity": True,  # À implémenter avec analyse 
  FFT
                  "dynamic_range_adequate": True,  # Variation pour Madd, 
  Qalqalah
                  "frequency_response_balanced": True,  # Pas de coupure 
  dans les graves/aigus
                  "duration_appropriate": 10 <= len(waveform[0]) /
  sample_rate <= 25,
                  "no_clipping": torch.max(torch.abs(waveform)) < 0.95
              }

              validation_results["overall_suitable"] =
  all(validation_results.values())

              return validation_results

          except Exception as e:
              return {"error": str(e), "overall_suitable": False}

      def process_all_reciters(self, source_dir):
          """
          Traiter tous les récitateurs d'un coup
          """
          source_path = Path(source_dir)
          results = {}

          for reciter_id in self.reciters_config.keys():
              # Chercher le fichier source
              possible_files = [
                  source_path / f"{reciter_id}_original.mp3",
                  source_path / f"{reciter_id}_original.wav",
                  source_path / f"{reciter_id}.mp3",
                  source_path / f"{reciter_id}.wav"
              ]

              source_file = None
              for pf in possible_files:
                  if pf.exists():
                      source_file = pf
                      break

              if source_file:
                  try:
                      print(f"\n🎯 Traitement de {reciter_id}...")
                      output_path, metadata = self.extract_optimal_segment(
                          str(source_file),
                          reciter_id
                      )

                      # Validation Tajweed
                      validation =
  self.validate_tajweed_compatibility(output_path)
                      metadata["tajweed_validation"] = validation

                      results[reciter_id] = {
                          "status": "success",
                          "output_path": output_path,
                          "metadata": metadata
                      }

                      if validation["overall_suitable"]:
                          print(f"✅ {reciter_id}: Prêt pour XTTS-v2")
                      else:
                          print(f"⚠️  {reciter_id}: Problèmes détectés, 
  vérification manuelle recommandée")

                  except Exception as e:
                      print(f"❌ Erreur pour {reciter_id}: {e}")
                      results[reciter_id] = {
                          "status": "error",
                          "error": str(e)
                      }
              else:
                  print(f"❌ Fichier source non trouvé pour {reciter_id}")
                  results[reciter_id] = {
                      "status": "missing_source",
                      "searched_files": [str(p) for p in possible_files]
                  }

          # Rapport final
          print(f"\n📋 RAPPORT DE TRAITEMENT")
          print("=" * 50)

          successful = 0
          for reciter_id, result in results.items():
              status_emoji = {
                  "success": "✅",
                  "error": "❌",
                  "missing_source": "📁"
              }.get(result["status"], "❓")

              print(f"{status_emoji} {reciter_id}: {result['status']}")

              if result["status"] == "success":
                  successful += 1

          print(f"\n🎯 Résultat: {successful}/{len(self.reciters_config)} 
  récitateurs traités avec succès")

          return results

  if __name__ == "__main__":
      import datetime
      from datetime import datetime

      parser = argparse.ArgumentParser(description="Préparer les 
  échantillons vocaux pour récitateurs coraniques")
      parser.add_argument("--source-dir", required=True, help="Répertoire 
  contenant les fichiers audio sources")
      parser.add_argument("--reciter", help="Traiter un récitateur 
  spécifique seulement")
      parser.add_argument("--analyze-only", action="store_true",
  help="Analyser la qualité sans traitement")

      args = parser.parse_args()

      preparer = QuranicVoicePreparer()

      if args.reciter:
          # Traiter un seul récitateur
          source_files =
  list(Path(args.source_dir).glob(f"{args.reciter}*"))
          if source_files:
              try:
                  output_path, metadata = preparer.extract_optimal_segment(
                      str(source_files[0]),
                      args.reciter
                  )
                  print(f"✅ Traitement terminé: {output_path}")
              except Exception as e:
                  print(f"❌ Erreur: {e}")
          else:
              print(f"❌ Aucun fichier trouvé pour {args.reciter}")
      else:
          # Traiter tous les récitateurs
          results = preparer.process_all_reciters(args.source_dir)

  2.2 Service XTTS-v2 pour Récitation Coranique

  Créer /var/coqui/quranic_voices/scripts/quranic_xtts_service.py:
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  Service XTTS-v2 optimisé pour la récitation coranique
  Intègre les règles de Tajweed et les optimisations de voix
  """

  import os
  import torch
  import torchaudio
  import json
  import time
  import gc
  from pathlib import Path
  from typing import Dict, Optional, List, Tuple
  from TTS.api import TTS
  import numpy as np

  class QuranicXTTSService:
      def __init__(self, base_dir="/var/coqui/quranic_voices", 
  low_memory_mode=True):
          self.base_dir = Path(base_dir)
          self.low_memory_mode = low_memory_mode
          self.device = "cuda" if torch.cuda.is_available() else "cpu"

          print(f"🎯 Initialisation QuranicXTTSService")
          print(f"📱 Device: {self.device}")
          print(f"💾 Mode mémoire: {'Économique' if low_memory_mode else 
  'Performance'}")

          # Optimisations mémoire pour VPS
          if self.low_memory_mode and self.device == "cpu":
              torch.set_num_threads(2)
              torch.set_grad_enabled(False)

          # Charger le modèle XTTS-v2
          self.tts = None
          self.load_model()

          # Configuration des récitateurs avec paramètres Tajweed
          self.reciters_config = self._load_reciters_config()

          # Cache pour optimiser les performances
          self.voice_embeddings_cache = {}

          print(f"✅ Service initialisé avec {len(self.reciters_config)} 
  récitateurs")

      def _load_reciters_config(self) -> Dict:
          """
          Charger la configuration des récitateurs avec paramètres de 
  Tajweed
          """
          config = {
              "mishary_rashid": {
                  "name": "Mishary Rashid Alafasy",
                  "name_arabic": "مشاري راشد العفاسي",
                  "sample_path": str(self.base_dir / "mishary_rashid" /
  "sample.wav"),
                  "voice_characteristics": {
                      "pitch_range": "medium-low",
                      "speed_base": 0.85,
                      "clarity_level": "high",
                      "tajweed_style": "classical"
                  },
                  "synthesis_params": {
                      "temperature": 0.5,      # Stabilité de la voix
                      "top_p": 0.85,          # Diversité contrôlée
                      "top_k": 50,            # Limitation du vocabulaire
                      "repetition_penalty": 1.1,
                      "length_penalty": 1.0
                  },
                  "tajweed_adjustments": {
                      "madd_emphasis": 1.2,    # Accentuation des 
  prolongations
                      "qalqalah_strength": 1.1, # Force des vibrations
                      "ghunna_duration": 1.0,   # Durée de nasalisation
                      "waqf_pause_factor": 1.0  # Facteur de pause
                  }
              },
              "sudais": {
                  "name": "Abdul Rahman As-Sudais",
                  "name_arabic": "عبد الرحمن السديس",
                  "sample_path": str(self.base_dir / "sudais" /
  "sample.wav"),
                  "voice_characteristics": {
                      "pitch_range": "medium",
                      "speed_base": 0.80,
                      "clarity_level": "very_high",
                      "tajweed_style": "madinah"
                  },
                  "synthesis_params": {
                      "temperature": 0.45,
                      "top_p": 0.80,
                      "top_k": 50,
                      "repetition_penalty": 1.2,
                      "length_penalty": 1.0
                  },
                  "tajweed_adjustments": {
                      "madd_emphasis": 1.3,
                      "qalqalah_strength": 1.2,
                      "ghunna_duration": 1.1,
                      "waqf_pause_factor": 1.2
                  }
              },
              "hudhaify": {
                  "name": "Ali Al-Hudhaify",
                  "name_arabic": "علي الحذيفي",
                  "sample_path": str(self.base_dir / "hudhaify" /
  "sample.wav"),
                  "voice_characteristics": {
                      "pitch_range": "medium-high",
                      "speed_base": 0.90,
                      "clarity_level": "high",
                      "tajweed_style": "classical"
                  },
                  "synthesis_params": {
                      "temperature": 0.5,
                      "top_p": 0.85,
                      "top_k": 50,
                      "repetition_penalty": 1.1,
                      "length_penalty": 1.0
                  },
                  "tajweed_adjustments": {
                      "madd_emphasis": 1.1,
                      "qalqalah_strength": 1.0,
                      "ghunna_duration": 0.9,
                      "waqf_pause_factor": 1.1
                  }
              },
              "afif_taj": {
                  "name": "Afif Mohammed Taj",
                  "name_arabic": "عفيف محمد تاج",
                  "sample_path": str(self.base_dir / "afif_taj" /
  "sample.wav"),
                  "voice_characteristics": {
                      "pitch_range": "medium",
                      "speed_base": 0.88,
                      "clarity_level": "high",
                      "tajweed_style": "modern"
                  },
                  "synthesis_params": {
                      "temperature": 0.55,
                      "top_p": 0.85,
                      "top_k": 50,
                      "repetition_penalty": 1.1,
                      "length_penalty": 1.0
                  },
                  "tajweed_adjustments": {
                      "madd_emphasis": 1.15,
                      "qalqalah_strength": 1.05,
                      "ghunna_duration": 1.0,
                      "waqf_pause_factor": 1.0
                  }
              }
          }

          # Vérifier que les échantillons existent
          available_reciters = {}
          for reciter_id, config_data in config.items():
              sample_path = config_data["sample_path"]
              if os.path.exists(sample_path):
                  available_reciters[reciter_id] = config_data
                  print(f"✅ {reciter_id}: Échantillon trouvé")
              else:
                  print(f"❌ {reciter_id}: Échantillon manquant - 
  {sample_path}")

          return available_reciters

      def load_model(self):
          """
          Charger le modèle XTTS-v2 avec optimisations
          """
          if self.tts is None:
              print("⏳ Chargement du modèle XTTS-v2...")
              start_time = time.time()

              try:
                  self.tts =
  TTS("tts_models/multilingual/multi-dataset/xtts_v2")

                  # Optimisations mémoire
                  if self.low_memory_mode:
                      if hasattr(self.tts.synthesizer.tts_model, 'half'):
                          self.tts.synthesizer.tts_model.half()
                          print("🔧 Mode FP16 activé")

                  self.tts.to(self.device)

                  load_time = time.time() - start_time
                  print(f"✅ Modèle chargé en {load_time:.1f}s")

              except Exception as e:
                  print(f"❌ Erreur chargement modèle: {e}")
                  raise

      def unload_model(self):
          """
          Libérer la mémoire du modèle
          """
          if self.tts:
              del self.tts
              self.tts = None
              self.voice_embeddings_cache.clear()
              gc.collect()

              if self.device == "cuda":
                  torch.cuda.empty_cache()

              print("🗑️  Modèle déchargé de la mémoire")

      def precompute_voice_embedding(self, reciter_id: str) -> bool:
          """
          Pré-calculer l'embedding vocal pour accélérer la synthèse
          """
          if reciter_id not in self.reciters_config:
              return False

          if reciter_id in self.voice_embeddings_cache:
              return True

          try:
              config = self.reciters_config[reciter_id]
              sample_path = config["sample_path"]

              print(f"🎤 Pré-calcul embedding pour {config['name']}...")

              # Charger et traiter l'échantillon
              if self.tts:
                  # Cette étape calcule l'embedding et le met en cache dans
   XTTS
                  test_synthesis = self.tts.tts(
                      text="اختبار",  # Test simple
                      speaker_wav=sample_path,
                      language="ar"
                  )

                  self.voice_embeddings_cache[reciter_id] = True
                  print(f"✅ Embedding calculé pour {reciter_id}")
                  return True

          except Exception as e:
              print(f"❌ Erreur pré-calcul {reciter_id}: {e}")
              return False

      def precompute_all_embeddings(self):
          """
          Pré-calculer tous les embeddings disponibles
          """
          print("🎯 Pré-calcul de tous les embeddings vocaux...")

          successful = 0
          for reciter_id in self.reciters_config.keys():
              if self.precompute_voice_embedding(reciter_id):
                  successful += 1

          print(f"✅ {successful}/{len(self.reciters_config)} embeddings 
  pré-calculés")
          return successful

      def apply_tajweed_processing(self, text: str, reciter_id: str) -> 
  str:
          """
          Appliquer un pré-traitement du texte selon les règles de Tajweed
          """
          if reciter_id not in self.reciters_config:
              return text

          adjustments =
  self.reciters_config[reciter_id]["tajweed_adjustments"]
          processed_text = text

          # Marquer les lettres de Qalqalah pour emphase
          qalqalah_letters = ['ق', 'ط', 'ب', 'ج', 'د']
          for letter in qalqalah_letters:
              if letter in processed_text:
                  # Ajouter une micro-pause après pour simuler la vibration
                  processed_text = processed_text.replace(letter,
  f"{letter}‎ ")

          # Marquer les Madd pour prolongation
          madd_patterns = ['آ', 'ا', 'و', 'ي']
          for pattern in madd_patterns:
              if pattern in processed_text and adjustments["madd_emphasis"]
   > 1.0:
                  # Ajouter des marqueurs de prolongation
                  processed_text = processed_text.replace(pattern,
  f"{pattern}ː")

          return processed_text.strip()

      def synthesize_ayah(self, 
                         text: str, 
                         reciter: str = "mishary_rashid",
                         apply_tajweed: bool = True,
                         output_path: Optional[str] = None) -> 
  Optional[np.ndarray]:
          """
          Synthétiser une ayah avec la voix d'un récitateur
          """

          if reciter not in self.reciters_config:
              available = ", ".join(self.reciters_config.keys())
              raise ValueError(f"Récitateur '{reciter}' non disponible. 
  Disponibles: {available}")

          config = self.reciters_config[reciter]
          sample_path = config["sample_path"]

          # Vérifier que l'échantillon existe
          if not os.path.exists(sample_path):
              raise FileNotFoundError(f"Échantillon manquant: 
  {sample_path}")

          # S'assurer que le modèle est chargé
          if self.tts is None:
              self.load_model()

          print(f"🎙️  Synthèse avec {config['name']} 
  ({config['name_arabic']})")
          print(f"📝 Texte: {text[:50]}{'...' if len(text) > 50 else ''}")

          try:
              # Pré-traitement Tajweed si demandé
              processed_text = self.apply_tajweed_processing(text, reciter)
   if apply_tajweed else text

              # Paramètres de synthèse
              synthesis_params = config["synthesis_params"].copy()
              synthesis_params.update({
                  "text": processed_text,
                  "speaker_wav": sample_path,
                  "language": "ar",
                  "speed": config["voice_characteristics"]["speed_base"]
              })

              start_time = time.time()

              # Synthèse avec gestion mémoire
              with torch.no_grad():
                  if output_path:
                      self.tts.tts_to_file(
                          file_path=output_path,
                          **synthesis_params
                      )
                      synthesis_time = time.time() - start_time
                      print(f"✅ Audio sauvegardé: {output_path} 
  ({synthesis_time:.1f}s)")
                      return output_path
                  else:
                      wav_data = self.tts.tts(**synthesis_params)
                      synthesis_time = time.time() - start_time
                      print(f"✅ Synthèse terminée en 
  {synthesis_time:.1f}s")
                      return wav_data

          except Exception as e:
              print(f"❌ Erreur synthèse {reciter}: {e}")
              return None
          finally:
              # Nettoyage mémoire si mode économique
              if self.low_memory_mode:
                  gc.collect()

      def batch_synthesize_surah(self, 
                                ayat_list: List[str], 
                                reciter: str = "mishary_rashid",
                                output_dir: Optional[str] = None) -> 
  List[str]:
          """
          Synthétiser une sourate complète (liste d'ayat)
          """

          if output_dir:
              output_path = Path(output_dir)
              output_path.mkdir(parents=True, exist_ok=True)
          else:
              output_path = self.base_dir / "output" / reciter
              output_path.mkdir(parents=True, exist_ok=True)

          print(f"📖 Synthèse de {len(ayat_list)} ayat avec {reciter}")

          results = []
          successful = 0

          for i, ayah in enumerate(ayat_list, 1):
              try:
                  filename = f"ayah_{i:03d}.wav"
                  file_path = output_path / filename

                  print(f"\n🎯 Ayah {i}/{len(ayat_list)}")

                  result = self.synthesize_ayah(
                      text=ayah,
                      reciter=reciter,
                      output_path=str(file_path)
                  )

                  if result:
                      results.append(str(file_path))
                      successful += 1
                  else:
                      results.append(None)

              except Exception as e:
                  print(f"❌ Erreur ayah {i}: {e}")
                  results.append(None)

          print(f"\n📊 Résultat: {successful}/{len(ayat_list)} ayat 
  synthétisées avec succès")
          return results

      def get_available_reciters(self) -> Dict[str, Dict]:
          """
          Retourner la liste des récitateurs disponibles avec leurs 
  informations
          """
          return {
              reciter_id: {
                  "name": config["name"],
                  "name_arabic": config["name_arabic"],
                  "style":
  config["voice_characteristics"]["tajweed_style"],
                  "available": os.path.exists(config["sample_path"])
              }
              for reciter_id, config in self.reciters_config.items()
          }

      def validate_setup(self) -> Dict[str, bool]:
          """
          Valider que tout est correctement configuré
          """
          validation = {
              "model_loaded": self.tts is not None,
              "device_available": True,
              "reciters_available": len(self.reciters_config) > 0,
              "samples_exist": all(
                  os.path.exists(config["sample_path"])
                  for config in self.reciters_config.values()
              )
          }

          validation["overall_ready"] = all(validation.values())

          return validation

  if __name__ == "__main__":
      # Test du service
      service = QuranicXTTSService()

      # Validation
      validation = service.validate_setup()
      print(f"\n🔍 VALIDATION DU SERVICE")
      print("=" * 40)
      for check, status in validation.items():
          emoji = "✅" if status else "❌"
          print(f"{emoji} {check}: {status}")

      if validation["overall_ready"]:
          print(f"\n🎯 Service prêt pour utilisation!")

          # Test simple avec Al-Fatiha
          print(f"\n🧪 Test de synthèse...")

          test_ayah = "بِسْمِ اللَّهِ الرَّحْمَٰنِ الرَّحِيمِ"

          for reciter in list(service.reciters_config.keys())[:2]:  # 
  Tester 2 récitateurs
              try:
                  output_file = f"/tmp/test_{reciter}.wav"
                  result = service.synthesize_ayah(
                      text=test_ayah,
                      reciter=reciter,
                      output_path=output_file
                  )

                  if result and os.path.exists(output_file):
                      file_size = os.path.getsize(output_file)
                      print(f"✅ Test {reciter}: {file_size} bytes")
                  else:
                      print(f"❌ Test {reciter}: Échec")

              except Exception as e:
                  print(f"❌ Test {reciter}: {e}")
      else:
          print(f"\n❌ Service non prêt - Corriger les problèmes 
  ci-dessus")

  3. Intégration API

  3.1 Extension de l'API Existante

  Modifier /var/coqui/main.py (ou créer un nouveau fichier):
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  API Coqui TTS étendue pour la récitation coranique
  Compatible avec l'implémentation Flutter existante
  """

  from fastapi import FastAPI, HTTPException, UploadFile, File
  from fastapi.responses import FileResponse, JSONResponse
  from fastapi.middleware.cors import CORSMiddleware
  from pydantic import BaseModel, Field
  from typing import Optional, List, Dict
  import os
  import sys
  import base64
  import hashlib
  import time
  from pathlib import Path

  # Ajouter le chemin des scripts
  sys.path.append('/var/coqui/quranic_voices/scripts')

  try:
      from quranic_xtts_service import QuranicXTTSService
      QURANIC_SERVICE_AVAILABLE = True
  except ImportError:
      QURANIC_SERVICE_AVAILABLE = False
      print("⚠️  Service coranique non disponible")

  # Configuration
  app = FastAPI(
      title="Coqui TTS API with Quranic Voices",
      description="TTS API avec support pour récitateurs coraniques",
      version="2.0.0"
  )

  # CORS pour Flutter
  app.add_middleware(
      CORSMiddleware,
      allow_origins=["*"],
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
  )

  # Service global
  quranic_service = None

  @app.on_event("startup")
  async def startup_event():
      """Initialiser les services au démarrage"""
      global quranic_service

      if QURANIC_SERVICE_AVAILABLE:
          try:
              print("🎯 Initialisation du service coranique...")
              quranic_service = QuranicXTTSService(low_memory_mode=True)

              validation = quranic_service.validate_setup()
              if validation["overall_ready"]:
                  print("✅ Service coranique prêt")
                  # Pré-calculer les embeddings pour de meilleures 
  performances
                  quranic_service.precompute_all_embeddings()
              else:
                  print("⚠️  Service coranique partiellement disponible")

          except Exception as e:
              print(f"❌ Erreur initialisation service coranique: {e}")
              quranic_service = None

  # Modèles Pydantic
  class TTSRequest(BaseModel):
      text: str = Field(..., description="Texte à synthétiser")
      language: str = Field(default="fr", description="Langue (ar, fr, 
  en)")
      voice_type: str = Field(default="male", description="Type de voix")
      rate: str = Field(default="+0%", description="Vitesse de parole")

  class QuranicTTSRequest(BaseModel):
      text: str = Field(..., description="Texte coranique à réciter")
      reciter: str = Field(default="mishary_rashid", description="ID du 
  récitateur")
      apply_tajweed: bool = Field(default=True, description="Appliquer les 
  règles de Tajweed")
      rate: str = Field(default="+0%", description="Ajustement de vitesse")

  class BatchQuranicRequest(BaseModel):
      ayat_list: List[str] = Field(..., description="Liste des ayat à 
  synthétiser")
      reciter: str = Field(default="mishary_rashid", description="ID du 
  récitateur")
      surah_name: Optional[str] = Field(None, description="Nom de la 
  sourate")

  # ============= ENDPOINTS EXISTANTS (Compatibilité) =============

  @app.post("/api/tts")
  async def synthesize_standard(request: TTSRequest):
      """
      Endpoint TTS standard (compatible avec l'implémentation Flutter 
  existante)
      """
      try:
          # Détecter si c'est du texte coranique
          is_arabic = any('\u0600' <= char <= '\u06FF' for char in
  request.text)

          if is_arabic and quranic_service and
  len(quranic_service.reciters_config) > 0:
              # Rediriger vers le service coranique avec récitateur par 
  défaut
              print(f"🔄 Redirection vers service coranique pour texte 
  arabe")

              quranic_request = QuranicTTSRequest(
                  text=request.text,
                  reciter="mishary_rashid",  # Récitateur par défaut
                  rate=request.rate
              )

              return await synthesize_quranic(quranic_request)

          else:
              # Service TTS standard pour les autres langues
              # TODO: Implémenter ou garder l'ancien service
              return {"error": "Service TTS standard non implémenté dans 
  cette version"}

      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))

  # ============= NOUVEAUX ENDPOINTS CORANIQUES =============

  @app.post("/api/tts/quranic")
  async def synthesize_quranic(request: QuranicTTSRequest):
      """
      Synthèse TTS avec voix de récitateurs coraniques
      """
      if not quranic_service:
          raise HTTPException(
              status_code=503,
              detail="Service de récitation coranique non disponible"
          )

      try:
          # Générer un nom de fichier unique
          text_hash = hashlib.md5(
              f"{request.text}_{request.reciter}_{request.rate}".encode()
          ).hexdigest()[:8]

          cache_dir = Path("/tmp/quranic_cache")
          cache_dir.mkdir(exist_ok=True)
          output_path = cache_dir / f"quranic_{text_hash}.wav"

          # Ajuster la vitesse selon le paramètre rate
          speed_adjustment = 1.0
          if request.rate.startswith('+'):
              speed_adjustment = 1.0 + (int(request.rate[1:-1]) / 100.0)
          elif request.rate.startswith('-'):
              speed_adjustment = 1.0 - (int(request.rate[1:-1]) / 100.0)

          # Synthétiser
          result = quranic_service.synthesize_ayah(
              text=request.text,
              reciter=request.reciter,
              apply_tajweed=request.apply_tajweed,
              output_path=str(output_path)
          )

          if result and output_path.exists():
              # Lire et encoder en base64 (compatibilité avec Flutter)
              with open(output_path, 'rb') as audio_file:
                  audio_data = audio_file.read()
                  audio_b64 = base64.b64encode(audio_data).decode()

              # Nettoyer le fichier temporaire
              try:
                  output_path.unlink()
              except:
                  pass

              return {
                  "audio": audio_b64,
                  "reciter": request.reciter,
                  "tajweed_applied": request.apply_tajweed,
                  "synthesis_time": time.time()
              }
          else:
              raise HTTPException(status_code=500, detail="Échec de la 
  synthèse")

      except ValueError as e:
          raise HTTPException(status_code=400, detail=str(e))
      except Exception as e:
          raise HTTPException(status_code=500, detail=f"Erreur synthèse: 
  {e}")

  @app.post("/api/tts/quranic/batch")
  async def synthesize_batch_quranic(request: BatchQuranicRequest):
      """
      Synthèse de plusieurs ayat (sourate complète)
      """
      if not quranic_service:
          raise HTTPException(
              status_code=503,
              detail="Service de récitation coranique non disponible"
          )

      try:
          # Créer un répertoire temporaire pour cette batch
          batch_id = hashlib.md5(

  f"{str(request.ayat_list)}_{request.reciter}_{time.time()}".encode()
          ).hexdigest()[:8]

          output_dir = Path(f"/tmp/quranic_batch_{batch_id}")
          output_dir.mkdir(exist_ok=True)

          # Synthétiser tous les ayat
          results = quranic_service.batch_synthesize_surah(
              ayat_list=request.ayat_list,
              reciter=request.reciter,
              output_dir=str(output_dir)
          )

          # Compiler les résultats
          batch_response = {
              "batch_id": batch_id,
              "reciter": request.reciter,
              "surah_name": request.surah_name,
              "total_ayat": len(request.ayat_list),
              "successful_ayat": len([r for r in results if r]),
              "files": []
          }

          for i, result_path in enumerate(results, 1):
              if result_path and os.path.exists(result_path):
                  # Encoder chaque fichier
                  with open(result_path, 'rb') as f:
                      audio_b64 = base64.b64encode(f.read()).decode()

                  batch_response["files"].append({
                      "ayah_number": i,
                      "audio": audio_b64,
                      "text": request.ayat_list[i-1]
                  })

          # Nettoyer les fichiers temporaires
          try:
              import shutil
              shutil.rmtree(output_dir)
          except:
              pass

          return batch_response

      except Exception as e:
          raise HTTPException(status_code=500, detail=f"Erreur batch: {e}")

  @app.get("/api/reciters")
  async def list_reciters():
      """
      Lister les récitateurs disponibles
      """
      if not quranic_service:
          return {"reciters": [], "message": "Service coranique non 
  disponible"}

      try:
          reciters = quranic_service.get_available_reciters()

          return {
              "reciters": reciters,
              "total": len(reciters),
              "service_status": "active"
          }

      except Exception as e:
          raise HTTPException(status_code=500, detail=str(e))

  @app.get("/api/reciters/{reciter_id}")
  async def get_reciter_info(reciter_id: str):
      """
      Informations détaillées sur un récitateur
      """
      if not quranic_service:
          raise HTTPException(status_code=503, detail="Service non 
  disponible")

      if reciter_id not in quranic_service.reciters_config:
          raise HTTPException(status_code=404, detail="Récitateur non 
  trouvé")

      config = quranic_service.reciters_config[reciter_id]

      return {
          "id": reciter_id,
          "name": config["name"],
          "name_arabic": config["name_arabic"],
          "voice_characteristics": config["voice_characteristics"],
          "available": os.path.exists(config["sample_path"]),
          "sample_exists": os.path.exists(config["sample_path"])
      }

  @app.post("/api/reciters/{reciter_id}/test")
  async def test_reciter(reciter_id: str):
      """
      Tester un récitateur avec la Basmalah
      """
      if not quranic_service:
          raise HTTPException(status_code=503, detail="Service non 
  disponible")

      test_request = QuranicTTSRequest(
          text="بِسْمِ اللَّهِ الرَّحْمَٰنِ الرَّحِيمِ",
          reciter=reciter_id
      )

      return await synthesize_quranic(test_request)

  # ============= ENDPOINTS DE GESTION =============

  @app.get("/api/status")
  async def get_status():
      """
      État du service
      """
      status = {
          "service": "Coqui TTS avec voix coraniques",
          "version": "2.0.0",
          "quranic_service_available": quranic_service is not None,
          "timestamp": time.time()
      }

      if quranic_service:
          validation = quranic_service.validate_setup()
          status.update({
              "quranic_validation": validation,
              "available_reciters": len(quranic_service.reciters_config),
              "device": quranic_service.device
          })

      return status

  @app.post("/api/admin/reload")
  async def reload_quranic_service():
      """
      Recharger le service coranique (admin)
      """
      global quranic_service

      try:
          if quranic_service:
              quranic_service.unload_model()

          quranic_service = QuranicXTTSService(low_memory_mode=True)
          validation = quranic_service.validate_setup()

          return {
              "status": "reloaded",
              "validation": validation,
              "timestamp": time.time()
          }

      except Exception as e:
          raise HTTPException(status_code=500, detail=f"Erreur 
  rechargement: {e}")

  # ============= ENDPOINT DE HEALTH CHECK =============

  @app.get("/health")
  @app.get("/")
  async def health_check():
      """
      Health check simple
      """
      return {
          "status": "healthy",
          "service": "Coqui TTS + Quranic Voices",
          "quranic_available": quranic_service is not None
      }

  if __name__ == "__main__":
      import uvicorn

      print("🚀 Démarrage du serveur Coqui TTS avec voix coraniques")
      print("📍 Endpoints disponibles:")
      print("   - POST /api/tts (standard, compatible Flutter)")
      print("   - POST /api/tts/quranic (récitateurs coraniques)")
      print("   - GET /api/reciters (liste des récitateurs)")
      print("   - GET /api/status (état du service)")

      uvicorn.run(
          app,
          host="0.0.0.0",
          port=8001,
          workers=1  # Un seul worker pour éviter les conflits GPU/mémoire
      )

  ---
  📝 Règles de Tajweed à Respecter

  1. Règles Prioritaires

  1.1 Madd (المد) - Prolongation

  🎯 RÈGLES DE BASE:
  - Madd Tabii (طبيعي): 2 temps - حروف المد (ا و ي)
  - Madd Wajib (واجب): 4-6 temps - avant همزة القطع
  - Madd Layyin (لين): 2-4-6 temps selon l'arrêt
  - Madd Silah (صلة): هـ الضمير connectée

  📝 IMPLÉMENTATION:
  - Détecter automatiquement les patterns ا, و, ي
  - Ajuster la durée selon le contexte
  - Vérifier la position dans le mot

  1.2 Qalqalah (القلقلة) - Vibration

  🎯 LETTRES CONCERNÉES: ق ط ب ج د

  📝 RÈGLES:
  - Qalqalah Kubra (كبرى): En fin de mot avec arrêt
  - Qalqalah Sughra (صغرى): En milieu de mot avec sukun
  - Force selon la position et le contexte

  📝 IMPLÉMENTATION:
  - Détecter les lettres ق ط ب ج د
  - Analyser la position (début, milieu, fin)
  - Appliquer la vibration appropriée

  1.3 Ghunna (الغنة) - Nasalisation

  🎯 DURÉE: 2 temps de base

  📝 RÈGLES:
  - Noon/Meem avec Shaddah: غنة كاملة
  - Idgham avec Ghunna: ي ن م و
  - Ikhfa: Nasalisation cachée

  📝 IMPLÉMENTATION:
  - Détecter ن et م avec diacritiques
  - Ajuster la nasalisation selon la règle
  - Maintenir la durée appropriée

  2. Règles d'Assimilation

  2.1 Idgham (الإدغام) - Fusion

  🎯 LETTRES: ي ر م ل ن و

  📝 TYPES:
  - Avec Ghunna: ي ن م و
  - Sans Ghunna: ل ر
  - Complet vs Partiel

  📝 IMPLÉMENTATION:
  - Détecter les rencontres Noon Sakinah + lettres Idgham
  - Appliquer la fusion appropriée
  - Préserver ou ajouter la Ghunna

  2.2 Ikhfa (الإخفاء) - Dissimulation

  🎯 15 LETTRES: ت ث ج د ذ ز س ش ص ض ط ظ ف ق ك

  📝 RÈGLE:
  - Noon Sakinah + une des 15 lettres
  - Nasalisation cachée sans fusion complète
  - Durée: 2 temps avec Ghunna

  📝 IMPLÉMENTATION:
  - Détecter Noon + lettres Ikhfa
  - Appliquer nasalisation intermédiaire
  - Éviter la fusion complète

  3. Règles de Pauses (Waqf)

  3.1 Signes de Ponctuation Coranique

  📝 SYMBOLES ET RÈGLES:
  ۖ (Must Stop) - Arrêt obligatoire
  ۗ (Permissible) - Arrêt permis
  ۘ (Prefer Continue) - Préférer continuer
  ۙ (Small Pause) - Petite pause
  ۚ (Stop Preferred) - Arrêt préférable

  📝 IMPLÉMENTATION:
  - Reconnaître les symboles Unicode
  - Appliquer les pauses appropriées
  - Respecter le sens du verset

  4. Validation Automatique

  4.1 Script de Validation Tajweed

  Créer /var/coqui/quranic_voices/scripts/tajweed_validator.py:
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  Validateur des règles de Tajweed pour la synthèse vocale
  """

  import re
  import unicodedata
  from typing import List, Dict, Tuple

  class TajweedValidator:
      def __init__(self):
          # Définition des lettres et règles
          self.madd_letters = ['ا', 'و', 'ي']
          self.qalqalah_letters = ['ق', 'ط', 'ب', 'ج', 'د']
          self.idgham_letters = ['ي', 'ر', 'م', 'ل', 'ن', 'و']
          self.ikhfa_letters = ['ت', 'ث', 'ج', 'د', 'ذ', 'ز', 'س', 'ش',
  'ص', 'ض', 'ط', 'ظ', 'ف', 'ق', 'ك']

          # Symboles de Waqf
          self.waqf_symbols = {
              '\u06D6': 'Must Stop',
              '\u06D7': 'Permissible',
              '\u06D8': 'Prefer Continue',
              '\u06D9': 'Small Pause',
              '\u06DA': 'Stop Preferred'
          }

      def analyze_text(self, text: str) -> Dict:
          """
          Analyser un texte coranique pour les règles de Tajweed
          """
          # Nettoyer le texte
          cleaned_text = self.clean_arabic_text(text)

          analysis = {
              'original_text': text,
              'cleaned_text': cleaned_text,
              'madd_occurrences': self.find_madd_rules(cleaned_text),
              'qalqalah_occurrences':
  self.find_qalqalah_rules(cleaned_text),
              'ghunna_occurrences': self.find_ghunna_rules(cleaned_text),
              'idgham_occurrences': self.find_idgham_rules(cleaned_text),
              'ikhfa_occurrences': self.find_ikhfa_rules(cleaned_text),
              'waqf_marks': self.find_waqf_marks(text),
              'complexity_score': 0
          }

          # Calculer un score de complexité Tajweed
          analysis['complexity_score'] =
  self.calculate_complexity(analysis)

          return analysis

      def clean_arabic_text(self, text: str) -> str:
          """Nettoyer le texte arabe en gardant les diacritiques 
  importantes"""
          # Garder les caractères arabes et diacritiques essentiels
          cleaned = re.sub(r'[^\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\s]',
   '', text)
          return cleaned.strip()

      def find_madd_rules(self, text: str) -> List[Dict]:
          """Identifier les occurrences de Madd"""
          madd_cases = []

          for i, char in enumerate(text):
              if char in self.madd_letters:
                  context = text[max(0, i-2):i+3]
                  madd_type = self.classify_madd_type(char, context, i,
  text)

                  madd_cases.append({
                      'position': i,
                      'letter': char,
                      'type': madd_type,
                      'context': context,
                      'recommended_duration':
  self.get_madd_duration(madd_type)
                  })

          return madd_cases

      def classify_madd_type(self, letter: str, context: str, position: 
  int, full_text: str) -> str:
          """Classifier le type de Madd"""
          # Logique simplifiée - à améliorer avec une analyse plus poussée
          next_char = full_text[position + 1] if position + 1 <
  len(full_text) else ''

          if next_char == 'ء':  # Hamza
              return 'Madd Wajib'
          elif position == len(full_text) - 1:  # Fin de mot
              return 'Madd Layyin'
          else:
              return 'Madd Tabii'

      def get_madd_duration(self, madd_type: str) -> int:
          """Obtenir la durée recommandée pour un type de Madd"""
          durations = {
              'Madd Tabii': 2,
              'Madd Wajib': 5,  # 4-6 temps, moyenne 5
              'Madd Layyin': 4,  # 2-4-6 selon contexte, moyenne 4
              'Madd Silah': 2
          }
          return durations.get(madd_type, 2)

      def find_qalqalah_rules(self, text: str) -> List[Dict]:
          """Identifier les lettres de Qalqalah"""
          qalqalah_cases = []

          for i, char in enumerate(text):
              if char in self.qalqalah_letters:
                  # Analyser si la lettre a un sukun ou est en fin de mot
                  next_char = text[i + 1] if i + 1 < len(text) else ''
                  is_end_of_word = next_char == ' ' or i == len(text) - 1

                  qalqalah_type = 'Kubra' if is_end_of_word else 'Sughra'

                  qalqalah_cases.append({
                      'position': i,
                      'letter': char,
                      'type': qalqalah_type,
                      'strength': 'Strong' if qalqalah_type == 'Kubra' else
   'Medium'
                  })

          return qalqalah_cases

      def find_ghunna_rules(self, text: str) -> List[Dict]:
          """Identifier les cas de Ghunna"""
          ghunna_cases = []

          for i, char in enumerate(text):
              if char in ['ن', 'م']:
                  # Vérifier les conditions pour Ghunna
                  next_char = text[i + 1] if i + 1 < len(text) else ''

                  if next_char == 'ّ':  # Shaddah
                      ghunna_cases.append({
                          'position': i,
                          'letter': char,
                          'type': 'Shaddah Ghunna',
                          'duration': 2
                      })

          return ghunna_cases

      def find_idgham_rules(self, text: str) -> List[Dict]:
          """Identifier les cas d'Idgham"""
          # Implémentation simplifiée
          # Dans une version complète, analyser les rencontres Noon Sakinah
   + lettres Idgham
          return []

      def find_ikhfa_rules(self, text: str) -> List[Dict]:
          """Identifier les cas d'Ikhfa"""
          # Implémentation simplifiée
          # Dans une version complète, analyser les rencontres Noon Sakinah
   + lettres Ikhfa
          return []

      def find_waqf_marks(self, text: str) -> List[Dict]:
          """Identifier les marques de Waqf"""
          waqf_marks = []

          for i, char in enumerate(text):
              if char in self.waqf_symbols:
                  waqf_marks.append({
                      'position': i,
                      'symbol': char,
                      'rule': self.waqf_symbols[char],
                      'unicode': f'U+{ord(char):04X}'
                  })

          return waqf_marks

      def calculate_complexity(self, analysis: Dict) -> float:
          """Calculer un score de complexité Tajweed"""
          score = 0

          # Compter les différents types de règles
          score += len(analysis['madd_occurrences']) * 1.0
          score += len(analysis['qalqalah_occurrences']) * 1.5
          score += len(analysis['ghunna_occurrences']) * 2.0
          score += len(analysis['idgham_occurrences']) * 2.5
          score += len(analysis['ikhfa_occurrences']) * 2.0
          score += len(analysis['waqf_marks']) * 1.0

          # Normaliser par rapport à la longueur du texte
          text_length = len(analysis['cleaned_text'])
          normalized_score = score / max(text_length, 1) * 100

          return min(normalized_score, 100)  # Cap à 100

  def validate_recitation_text(text: str) -> Dict:
      """
      Fonction principale de validation pour un texte de récitation
      """
      validator = TajweedValidator()
      analysis = validator.analyze_text(text)

      # Ajouter des recommandations
      recommendations = []

      if analysis['complexity_score'] > 70:
          recommendations.append("Texte complexe - synthèse lente 
  recommandée")

      if len(analysis['madd_occurrences']) > 5:
          recommendations.append("Nombreux Madd - attention aux 
  prolongations")

      if len(analysis['qalqalah_occurrences']) > 3:
          recommendations.append("Qalqalah multiples - emphase sur les 
  vibrations")

      analysis['recommendations'] = recommendations
      analysis['suitable_for_synthesis'] = analysis['complexity_score'] <
  80

      return analysis

  if __name__ == "__main__":
      # Test avec Al-Fatiha
      test_texts = [
          "بِسْمِ اللَّهِ الرَّحْمَٰنِ الرَّحِيمِ",
          "الْحَمْدُ لِلَّهِ رَبِّ الْعَالَمِينَ",
          "قُلْ هُوَ اللَّهُ أَحَدٌ"
      ]

      for text in test_texts:
          print(f"\n📝 Analyse: {text}")
          print("=" * 50)

          result = validate_recitation_text(text)

          print(f"🎯 Score complexité: {result['complexity_score']:.1f}")
          print(f"🎤 Adapté synthèse: {'Oui' if 
  result['suitable_for_synthesis'] else 'Non'}")

          if result['madd_occurrences']:
              print(f"📏 Madd trouvés: {len(result['madd_occurrences'])}")

          if result['qalqalah_occurrences']:
              print(f"🔸 Qalqalah trouvés: 
  {len(result['qalqalah_occurrences'])}")

          if result['recommendations']:
              print("💡 Recommandations:")
              for rec in result['recommendations']:
                  print(f"   - {rec}")

  ---
  🧪 Tests et Validation

  1. Corpus de Test Coranique

  1.1 Versets de Validation par Complexité

  Créer /var/coqui/quranic_voices/tests/test_corpus.json:
  {
    "test_categories": {
      "simple": {
        "description": "Versets simples pour tests de base",
        "texts": [
          {
            "id": "basmalah",
            "arabic": "بِسْمِ اللَّهِ الرَّحْمَٰنِ الرَّحِيمِ",
            "transliteration": "Bismillahi ar-Rahmani ar-Raheem",
            "source": "Début de chaque sourate",
            "tajweed_focus": ["Madd Tabii", "Lam Shamsiyyah"],
            "complexity": 2
          },
          {
            "id": "ikhlas_1",
            "arabic": "قُلْ هُوَ اللَّهُ أَحَدٌ",
            "transliteration": "Qul huwa Allahu ahad",
            "source": "Sourate Al-Ikhlas, Verset 1",
            "tajweed_focus": ["Qalqalah", "Sukun"],
            "complexity": 3
          }
        ]
      },
      "medium": {
        "description": "Versets avec règles de Tajweed modérées",
        "texts": [
          {
            "id": "fatiha_2",
            "arabic": "الْحَمْدُ لِلَّهِ رَبِّ الْعَالَمِينَ",
            "transliteration": "Alhamdu lillahi rabbi al-alameen",
            "source": "Al-Fatiha, Verset 2",
            "tajweed_focus": ["Madd Tabii", "Lam Shamsiyyah", "Noon 
  Sakinah"],
            "complexity": 5
          },
          {
            "id": "adiyat_1",
            "arabic": "وَالْعَادِيَاتِ ضَبْحًا",
            "transliteration": "Wal-adiyati dabha",
            "source": "Sourate Al-Adiyat, Verset 1",
            "tajweed_focus": ["Waw Sakt", "Tanween", "Idgham"],
            "complexity": 6
          }
        ]
      },
      "complex": {
        "description": "Versets complexes avec multiples règles",
        "texts": [
          {
            "id": "baqarah_255",
            "arabic": "اللَّهُ لَا إِلَٰهَ إِلَّا هُوَ الْحَيُّ الْقَيُّومُ",
            "transliteration": "Allahu la ilaha illa huwa al-hayyu 
  al-qayyum",
            "source": "Al-Baqarah, Verset 255 (début)",
            "tajweed_focus": ["Madd Wajib", "Shaddah", "Qalqalah",
  "Ghunna"],
            "complexity": 8
          }
        ]
      }
    },
    "validation_criteria": {
      "pronunciation_accuracy": "Respect des lettres arabes et 
  diacritiques",
      "tajweed_rules": "Application correcte des règles identifiées",
      "rhythm_flow": "Fluidité naturelle de la récitation",
      "voice_consistency": "Cohérence avec le style du récitateur"
    },
    "expected_durations": {
      "basmalah": "4-6 secondes",
      "short_ayah": "3-8 secondes",
      "medium_ayah": "8-15 secondes",
      "long_ayah": "15-30 secondes"
    }
  }

  1.2 Script de Test Automatisé

  Créer /var/coqui/quranic_voices/scripts/run_tests.py:
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  """
  Suite de tests automatisés pour le système de récitation coranique
  """

  import json
  import time
  import os
  import sys
  from pathlib import Path
  from typing import Dict, List
  import librosa
  import numpy as np

  # Ajouter le chemin des scripts
  sys.path.append('/var/coqui/quranic_voices/scripts')

  try:
      from quranic_xtts_service import QuranicXTTSService
      from tajweed_validator import validate_recitation_text
  except ImportError as e:
      print(f"❌ Erreur import: {e}")
      sys.exit(1)

  class QuranicTTSTestSuite:
      def __init__(self):
          self.service = None
          self.test_results = []
          self.output_dir = Path("/var/coqui/quranic_voices/tests/outputs")
          self.output_dir.mkdir(parents=True, exist_ok=True)

          # Charger le corpus de test
          self.load_test_corpus()

      def load_test_corpus(self):
          """Charger le corpus de test"""
          corpus_path =
  Path("/var/coqui/quranic_voices/tests/test_corpus.json")

          if corpus_path.exists():
              with open(corpus_path, 'r', encoding='utf-8') as f:
                  self.test_corpus = json.load(f)
          else:
              print(f"⚠️  Corpus de test non trouvé: {corpus_path}")
              self.test_corpus = {"test_categories": {}}

      def setup_service(self):
          """Initialiser le service de récitation"""
          try:
              print("🎯 Initialisation du service de test...")
              self.service = QuranicXTTSService(low_memory_mode=True)

              validation = self.service.validate_setup()
              if not validation["overall_ready"]:
                  print(f"⚠️  Service partiellement prêt: {validation}")

              return True

          except Exception as e:
              print(f"❌ Erreur initialisation service: {e}")
              return False

      def test_single_reciter(self, reciter_id: str, test_texts: 
  List[Dict]) -> Dict:
          """Tester un récitateur avec une liste de textes"""

          if not self.service or reciter_id not in
  self.service.reciters_config:
              return {"error": f"Récitateur {reciter_id} non disponible"}

          reciter_results = {
              "reciter_id": reciter_id,
              "reciter_name":
  self.service.reciters_config[reciter_id]["name"],
              "tests": [],
              "summary": {
                  "total": len(test_texts),
                  "successful": 0,
                  "failed": 0,
                  "avg_synthesis_time": 0,
                  "avg_audio_duration": 0
              }
          }

          print(f"\n🎤 Test du récitateur: 
  {reciter_results['reciter_name']}")
          print("-" * 50)

          synthesis_times = []
          audio_durations = []

          for i, test_text in enumerate(test_texts, 1):
              print(f"📝 Test {i}/{len(test_texts)}: {test_text['id']}")

              # Générer le fichier de sortie
              output_file = self.output_dir /
  f"{reciter_id}_{test_text['id']}.wav"

              # Analyser le texte pour Tajweed
              tajweed_analysis =
  validate_recitation_text(test_text['arabic'])

              test_result = {
                  "test_id": test_text['id'],
                  "text": test_text['arabic'],
                  "transliteration": test_text.get('transliteration', ''),
                  "complexity": test_text.get('complexity', 0),
                  "tajweed_analysis": tajweed_analysis,
                  "synthesis_successful": False,
                  "synthesis_time": 0,
                  "audio_duration": 0,
                  "audio_quality": {},
                  "output_file": str(output_file)
              }

              try:
                  # Synthèse
                  start_time = time.time()

                  result = self.service.synthesize_ayah(
                      text=test_text['arabic'],
                      reciter=reciter_id,
                      apply_tajweed=True,
                      output_path=str(output_file)
                  )

                  synthesis_time = time.time() - start_time
                  test_result["synthesis_time"] = synthesis_time
                  synthesis_times.append(synthesis_time)

                  if result and output_file.exists():
                      test_result["synthesis_successful"] = True
                      reciter_results["summary"]["successful"] += 1

                      # Analyser l'audio généré
                      audio_analysis =
  self.analyze_audio_quality(str(output_file))
                      test_result["audio_quality"] = audio_analysis
                      test_result["audio_duration"] =
  audio_analysis.get("duration", 0)

                      if audio_analysis.get("duration", 0) > 0:

  audio_durations.append(audio_analysis["duration"])

                      print(f"  ✅ Succès ({synthesis_time:.1f}s)")

                  else:
                      print(f"  ❌ Échec de synthèse")
                      reciter_results["summary"]["failed"] += 1

              except Exception as e:
                  print(f"  ❌ Erreur: {e}")
                  test_result["error"] = str(e)
                  reciter_results["summary"]["failed"] += 1

              reciter_results["tests"].append(test_result)

          # Calculer les moyennes
          if synthesis_times:
              reciter_results["summary"]["avg_synthesis_time"] =
  np.mean(synthesis_times)
          if audio_durations:
              reciter_results["summary"]["avg_audio_duration"] =
  np.mean(audio_durations)

          return reciter_results

      def analyze_audio_quality(self, audio_path: str) -> Dict:
          """Analyser la qualité de l'audio généré"""
          try:
              # Charger l'audio avec librosa
              y, sr = librosa.load(audio_path, sr=None)

              analysis = {
                  "file_exists": True,
                  "sample_rate": sr,
                  "duration": len(y) / sr,
                  "rms_energy": float(np.sqrt(np.mean(y**2))),
                  "zero_crossing_rate":
  float(np.mean(librosa.feature.zero_crossing_rate(y)[0])),
                  "spectral_centroid":
  float(np.mean(librosa.feature.spectral_centroid(y=y, sr=sr)[0])),
                  "file_size_bytes": os.path.getsize(audio_path)
              }

              # Validation de base
              analysis["quality_flags"] = []

              if analysis["duration"] < 1.0:
                  analysis["quality_flags"].append("Durée très courte")
              elif analysis["duration"] > 30.0:
                  analysis["quality_flags"].append("Durée très longue")

              if analysis["rms_energy"] < 0.01:
                  analysis["quality_flags"].append("Volume très faible")
              elif analysis["rms_energy"] > 0.8:
                  analysis["quality_flags"].append("Risque de saturation")

              analysis["overall_quality"] = "good" if
  len(analysis["quality_flags"]) == 0 else "issues"

              return analysis

          except Exception as e:
              return {
                  "file_exists": os.path.exists(audio_path),
                  "error": str(e),
                  "overall_quality": "error"
              }

      def run_comprehensive_tests(self) -> Dict:
          """Exécuter tous les tests de manière exhaustive"""
          print("🧪 DÉBUT DES TESTS COMPLETS")
          print("=" * 60)

          if not self.setup_service():
              return {"error": "Impossible d'initialiser le service"}

          # Collecter tous les textes de test
          all_test_texts = []
          for category, data in self.test_corpus.get("test_categories",
  {}).items():
              all_test_texts.extend(data.get("texts", []))

          if not all_test_texts:
              return {"error": "Aucun texte de test trouvé"}

          print(f"📝 {len(all_test_texts)} textes de test préparés")

          # Tester tous les récitateurs disponibles
          test_results = {
              "timestamp": time.time(),
              "test_summary": {
                  "total_reciters": 0,
                  "total_tests": 0,
                  "successful_tests": 0,
                  "failed_tests": 0
              },
              "reciters": {}
          }

          available_reciters = list(self.service.reciters_config.keys())
          test_results["test_summary"]["total_reciters"] =
  len(available_reciters)

          for reciter_id in available_reciters:
              print(f"\n🎯 TEST RÉCITATEUR: {reciter_id}")

              reciter_result = self.test_single_reciter(reciter_id,
  all_test_texts)
              test_results["reciters"][reciter_id] = reciter_result

              # Mise à jour du résumé global
              if "summary" in reciter_result:
                  test_results["test_summary"]["total_tests"] +=
  reciter_result["summary"]["total"]
                  test_results["test_summary"]["successful_tests"] +=
  reciter_result["summary"]["successful"]
                  test_results["test_summary"]["failed_tests"] +=
  reciter_result["summary"]["failed"]

          # Sauvegarder les résultats
          results_file = self.output_dir /
  f"test_results_{int(time.time())}.json"
          with open(results_file, 'w', encoding='utf-8') as f:
              json.dump(test_results, f, indent=2, ensure_ascii=False)

          print(f"\n📊 RÉSUMÉ DES TESTS")
          print("=" * 40)
          print(f"Récitateurs testés: 
  {test_results['test_summary']['total_reciters']}")
          print(f"Tests totaux: 
  {test_results['test_summary']['total_tests']}")
          print(f"Succès: 
  {test_results['test_summary']['successful_tests']}")
          print(f"Échecs: {test_results['test_summary']['failed_tests']}")

          if test_results['test_summary']['total_tests'] > 0:
              success_rate =
  (test_results['test_summary']['successful_tests'] /
                            test_results['test_summary']['total_tests']) *
  100
              print(f"Taux de succès: {success_rate:.1f}%")

          print(f"📄 Résultats détaillés: {results_file}")

          return test_results

      def run_quick_test(self) -> bool:
          """Test rapide avec la Basmalah sur tous les récitateurs"""
          print("⚡ TEST RAPIDE - Basmalah")
          print("-" * 30)

          if not self.setup_service():
              return False

          test_text = "بِسْمِ اللَّهِ الرَّحْمَٰنِ الرَّحِيمِ"
          all_passed = True

          for reciter_id in self.service.reciters_config.keys():
              try:
                  output_file = f"/tmp/quick_test_{reciter_id}.wav"

                  result = self.service.synthesize_ayah(
                      text=test_text,
                      reciter=reciter_id,
                      output_path=output_file
                  )

                  if result and os.path.exists(output_file):
                      file_size = os.path.getsize(output_file)
                      print(f"✅ {reciter_id}: {file_size} bytes")

                      # Nettoyer
                      try:
                          os.remove(output_file)
                      except:
                          pass
                  else:
                      print(f"❌ {reciter_id}: Échec")
                      all_passed = False

              except Exception as e:
                  print(f"❌ {reciter_id}: {e}")
                  all_passed = False

          return all_passed

  if __name__ == "__main__":
      import argparse

      parser = argparse.ArgumentParser(description="Tests automatisés pour 
  TTS coranique")
      parser.add_argument("--quick", action="store_true", help="Test rapide
   seulement")
      parser.add_argument("--reciter", help="Tester un récitateur 
  spécifique")

      args = parser.parse_args()

      test_suite = QuranicTTSTestSuite()

      if args.quick:
          success = test_suite.run_quick_test()
          sys.exit(0 if success else 1)
      elif args.reciter:
          if not test_suite.setup_service():
              sys.exit(1)

          # Collecter les textes de test
          all_texts = []
          for category, data in
  test_suite.test_corpus.get("test_categories", {}).items():
              all_texts.extend(data.get("texts", []))

          if all_texts:
              result = test_suite.test_single_reciter(args.reciter,
  all_texts[:3])  # 3 premiers textes
              print(f"\n📊 Résultat pour {args.reciter}:")
              print(f"Succès: {result.get('summary', {}).get('successful', 
  0)}")
              print(f"Échecs: {result.get('summary', {}).get('failed', 
  0)}")
          else:
              print("❌ Aucun texte de test disponible")
              sys.exit(1)
      else:
          # Tests complets
          results = test_suite.run_comprehensive_tests()

          if "error" in results:
              print(f"❌ Erreur: {results['error']}")
              sys.exit(1)

          # Exit code basé sur le taux de succès
          total = results['test_summary']['total_tests']
          successful = results['test_summary']['successful_tests']

          if total > 0 and (successful / total) >= 0.8:  # 80% de succès 
  minimum
              sys.exit(0)
          else:
              sys.exit(1)

  ---
  🚀 Maintenance et Surveillance

  1. Monitoring Système

  1.1 Script de Surveillance

  Créer /var/coqui/quranic_voices/scripts/monitor_service.py:
  #!/usr/bin/env python3
  """
  Surveillance continue du service TTS coranique
  """

  import time
  import json
  import psutil
  import requests
  from pathlib import Path
  import logging

  # Configuration du logging
  logging.basicConfig(
      level=logging.INFO,
      format='%(asctime)s - %(levelname)s - %(message)s',
      handlers=[
          logging.FileHandler('/var/log/quranic_tts_monitor.log'),
          logging.StreamHandler()
      ]
  )

  class QuranicTTSMonitor:
      def __init__(self):
          self.api_endpoint = "http://168.231.112.71:8001"
          self.check_interval = 300  # 5 minutes
          self.alert_threshold = {
              "cpu_percent": 80,
              "memory_percent": 85,
              "disk_percent": 90,
              "response_time": 10.0
          }

      def check_api_health(self):
          """Vérifier l'état de l'API"""
          try:
              start_time = time.time()
              response = requests.get(f"{self.api_endpoint}/api/status",
  timeout=10)
              response_time = time.time() - start_time

              if response.status_code == 200:
                  data = response.json()
                  return {
                      "status": "healthy",
                      "response_time": response_time,
                      "data": data
                  }
              else:
                  return {
                      "status": "error",
                      "http_code": response.status_code,
                      "response_time": response_time
                  }

          except Exception as e:
              return {
                  "status": "error",
                  "error": str(e),
                  "response_time": None
              }

      def check_system_resources(self):
          """Vérifier les ressources système"""
          try:
              cpu_percent = psutil.cpu_percent(interval=1)
              memory = psutil.virtual_memory()
              disk = psutil.disk_usage('/')

              return {
                  "cpu_percent": cpu_percent,
                  "memory_percent": memory.percent,
                  "memory_available_gb": memory.available / 1024**3,
                  "disk_percent": disk.percent,
                  "disk_free_gb": disk.free / 1024**3
              }

          except Exception as e:
              logging.error(f"Erreur vérification ressources: {e}")
              return None

      def test_synthesis(self):
          """Tester la synthèse avec un texte simple"""
          try:
              test_payload = {
                  "text": "بِسْمِ اللَّهِ الرَّحْمَٰنِ الرَّحِيمِ",
                  "reciter": "mishary_rashid"
              }

              start_time = time.time()
              response = requests.post(
                  f"{self.api_endpoint}/api/tts/quranic",
                  json=test_payload,
                  timeout=30
              )
              synthesis_time = time.time() - start_time

              if response.status_code == 200:
                  data = response.json()
                  audio_size = len(data.get("audio", "")) if "audio" in
  data else 0

                  return {
                      "status": "success",
                      "synthesis_time": synthesis_time,
                      "audio_size": audio_size
                  }
              else:
                  return {
                      "status": "error",
                      "http_code": response.status_code,
                      "synthesis_time": synthesis_time
                  }

          except Exception as e:
              return {
                  "status": "error",
                  "error": str(e)
              }

      def run_monitoring_cycle(self):
          """Exécuter un cycle de surveillance complet"""
          logging.info("🔍 Début cycle de surveillance")

          # 1. Vérifier l'API
          api_health = self.check_api_health()
          logging.info(f"API Status: {api_health['status']}")

          if api_health["response_time"] and api_health["response_time"] >
  self.alert_threshold["response_time"]:
              logging.warning(f"⚠️  API lente: 
  {api_health['response_time']:.1f}s")

          # 2. Vérifier les ressources
          resources = self.check_system_resources()
          if resources:
              logging.info(f"Ressources - CPU: 
  {resources['cpu_percent']:.1f}%, "
                          f"RAM: {resources['memory_percent']:.1f}%, "
                          f"Disk: {resources['disk_percent']:.1f}%")

              # Alertes
              if resources["cpu_percent"] >
  self.alert_threshold["cpu_percent"]:
                  logging.warning(f"🔥 CPU élevé: 
  {resources['cpu_percent']:.1f}%")

              if resources["memory_percent"] >
  self.alert_threshold["memory_percent"]:
                  logging.warning(f"💾 Mémoire élevée: 
  {resources['memory_percent']:.1f}%")

              if resources["disk_percent"] >
  self.alert_threshold["disk_percent"]:
                  logging.warning(f"💽 Disque plein: 
  {resources['disk_percent']:.1f}%")

          # 3. Tester la synthèse
          if api_health["status"] == "healthy":
              synthesis_test = self.test_synthesis()
              if synthesis_test["status"] == "success":
                  logging.info(f"✅ Test synthèse OK 
  ({synthesis_test['synthesis_time']:.1f}s)")
              else:
                  logging.error(f"❌ Test synthèse échoué: 
  {synthesis_test}")

          # 4. Rapport complet
          report = {
              "timestamp": time.time(),
              "api_health": api_health,
              "system_resources": resources,
              "synthesis_test": synthesis_test if api_health["status"] ==
  "healthy" else None
          }

          # Sauvegarder le rapport
          report_file =
  f"/var/log/quranic_tts_report_{int(time.time())}.json"
          with open(report_file, 'w') as f:
              json.dump(report, f, indent=2)

          return report

      def run_continuous_monitoring(self):
          """Surveillance continue"""
          logging.info(f"🎯 Démarrage surveillance continue (intervalle: 
  {self.check_interval}s)")

          while True:
              try:
                  self.run_monitoring_cycle()
                  time.sleep(self.check_interval)

              except KeyboardInterrupt:
                  logging.info("🛑 Arrêt de la surveillance")
                  break
              except Exception as e:
                  logging.error(f"❌ Erreur surveillance: {e}")
                  time.sleep(60)  # Pause d'1 minute en cas d'erreur

  if __name__ == "__main__":
      import argparse

      parser = argparse.ArgumentParser(description="Surveillance TTS 
  Coranique")
      parser.add_argument("--once", action="store_true", help="Un seul 
  cycle de vérification")
      parser.add_argument("--interval", type=int, default=300,
  help="Intervalle entre vérifications (secondes)")

      args = parser.parse_args()

      monitor = QuranicTTSMonitor()
      monitor.check_interval = args.interval

      if args.once:
          report = monitor.run_monitoring_cycle()
          print(json.dumps(report, indent=2))
      else:
          monitor.run_continuous_monitoring()

  2. Script de Maintenance

  Créer /var/coqui/quranic_voices/scripts/maintenance.sh:
  #!/bin/bash
  # Maintenance automatique du système TTS coranique

  LOG_FILE="/var/log/quranic_tts_maintenance.log"
  BACKUP_DIR="/var/backups/quranic_tts"
  MAX_CACHE_SIZE_MB=500

  log_message() {
      echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
  }

  # Création du répertoire de backup
  mkdir -p "$BACKUP_DIR"

  log_message "🧹 Début maintenance TTS Coranique"

  # 1. Nettoyer les fichiers temporaires
  log_message "🗑️  Nettoyage fichiers temporaires"
  find /tmp -name "quranic_*" -type f -mtime +1 -delete 2>/dev/null
  find /tmp -name "test_*.wav" -type f -mtime +1 -delete 2>/dev/null

  # 2. Gérer le cache
  CACHE_DIR="/var/coqui/quranic_voices/cache"
  if [ -d "$CACHE_DIR" ]; then
      CACHE_SIZE=$(du -sm "$CACHE_DIR" | cut -f1)
      log_message "📦 Taille cache actuelle: ${CACHE_SIZE}MB"

      if [ "$CACHE_SIZE" -gt "$MAX_CACHE_SIZE_MB" ]; then
          log_message "⚠️  Cache trop volumineux, nettoyage..."
          find "$CACHE_DIR" -type f -mtime +7 -delete
          NEW_SIZE=$(du -sm "$CACHE_DIR" | cut -f1)
          log_message "✅ Nouveau cache: ${NEW_SIZE}MB"
      fi
  fi

  # 3. Rotation des logs
  log_message "📝 Rotation des logs"
  if [ -f "/var/log/quranic_tts_monitor.log" ]; then
      if [ $(stat -f%z "/var/log/quranic_tts_monitor.log" 2>/dev/null ||
  stat -c%s "/var/log/quranic_tts_monitor.log") -gt 10485760 ]; then
          mv "/var/log/quranic_tts_monitor.log"
  "/var/log/quranic_tts_monitor.log.old"
          touch "/var/log/quranic_tts_monitor.log"
          log_message "✅ Log rotaté"
      fi
  fi

  # 4. Vérifier l'espace disque
  DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
  log_message "💽 Utilisation disque: ${DISK_USAGE}%"

  if [ "$DISK_USAGE" -gt 85 ]; then
      log_message "🚨 ALERTE: Espace disque critique!"
      # Nettoyer plus agressivement
      find /tmp -type f -mtime +0 -delete 2>/dev/null
  fi

  # 5. Vérifier l'état du service
  if systemctl is-active --quiet coqui-tts; then
      log_message "✅ Service TTS actif"
  else
      log_message "⚠️  Service TTS inactif - tentative de redémarrage"
      systemctl restart coqui-tts
      sleep 5
      if systemctl is-active --quiet coqui-tts; then
          log_message "✅ Service redémarré avec succès"
      else
          log_message "❌ Échec redémarrage service"
      fi
  fi

  # 6. Backup des configurations importantes
  log_message "💾 Backup configurations"
  BACKUP_TODAY="$BACKUP_DIR/backup_$(date +%Y%m%d)"
  mkdir -p "$BACKUP_TODAY"

  # Sauvegarder les échantillons vocaux et métadonnées
  if [ -d "/var/coqui/quranic_voices" ]; then
      tar -czf "$BACKUP_TODAY/quranic_voices_config.tar.gz" \
          --exclude="*.wav" --exclude="cache" --exclude="tests/outputs" \
          "/var/coqui/quranic_voices" 2>/dev/null
  fi

  # Nettoyer les vieux backups (>30 jours)
  find "$BACKUP_DIR" -type d -name "backup_*" -mtime +30 -exec rm -rf {} \;
   2>/dev/null

  log_message "✅ Maintenance terminée"

  # 7. Test rapide du service
  log_message "🧪 Test rapide du service"
  python3 /var/coqui/quranic_voices/scripts/run_tests.py --quick >>
  "$LOG_FILE" 2>&1

  if [ $? -eq 0 ]; then
      log_message "✅ Service fonctionnel"
  else
      log_message "⚠️  Problèmes détectés dans les tests"
  fi

  log_message "🏁 Maintenance complète"

  ---
  📋 Checklist Finale

  ✅ Actions Utilisateur Requises

  Phase 1 - Préparation Audio (CRITIQUE)
  - Obtenir échantillons audio de 15-25s pour chaque récitateur
  - Vérifier les droits d'usage des enregistrements
  - Placer fichiers dans /audio_samples/source/
  - Créer test_corpus.json avec versets de validation

  Phase 2 - Accès Serveur
  - Fournir accès SSH au VPS (168.231.112.71)
  - Confirmer utilisateur avec droits sudo
  - Vérifier espace disque disponible (>5GB)
  - Effectuer backup du système actuel

  🤖 Actions Assistant Automatisées

  Installation et Configuration
  - Installation dépendances Python (TTS, torch, torchaudio)
  - Création structure répertoires
  - Déploiement scripts de traitement
  - Configuration service XTTS coranique

  Intégration API
  - Extension API existante avec endpoints coraniques
  - Maintien compatibilité Flutter existante
  - Tests automatisés de tous les récitateurs
  - Configuration monitoring et maintenance

  🎯 Critères de Réussite

  Fonctionnalité
  - 4 récitateurs fonctionnels (Mishary, Sudais, Hudhaify, Afif)
  - Synthèse respectant les règles de Tajweed
  - Cache optimisé pour performances
  - API compatible avec app Flutter existante

  Performance
  - Synthèse <10s pour versets courts
  - Cache hit instantané
  - Mémoire <4GB en utilisation normale
  - Taux de succès >90% sur tests automatisés

  Qualité Audio
  - Respect des caractéristiques vocales de chaque récitateur
  - Application correcte des règles de Madd, Qalqalah, Ghunna
  - Fluidité naturelle de récitation
  - Absence de distorsions ou artefacts

  ---
  Temps estimé total: 5-7 jours de travail
  Ressources VPS minimales: 4GB RAM, 4 CPU cores, 5GB stockage libre
  Compatibilité: Maintient 100% la compatibilité avec l'app Flutter
  existante

  Ce mémoire constitue un guide complet pour implémenter la récitation
  coranique authentique avec Tajweed dans votre système TTS Coqui existant.

